#!/usr/bin/env python3"""Script de Actualizaci√≥n del Dashboard - Progol Engine v2Actualiza el dashboard existente con las nuevas funcionalidades"""import osimport sysimport shutilimport jsonimport loggingfrom pathlib import Pathfrom datetime import datetimefrom typing import Dict, List, Optional, Tuple# Configuraci√≥n de logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)class DashboardUpdater:    """Actualizador del dashboard existente"""        def __init__(self, backup: bool = True):        self.backup_enabled = backup        self.backup_dir = None        self.current_dir = Path.cwd()                # Archivos y directorios a actualizar        self.files_to_update = {            'streamlit_app/dashboard.py': 'dashboard_mejorado.py',            'src/utils/config.py': 'config_actualizado.py',            'src/optimizer/generate_core_v2.py': 'optimizador_mejorado.py',            'src/utils/file_utils.py': 'utilidades_archivos.py',            'src/simulation/montecarlo_sim.py': 'simulador_montecarlo.py',            'streamlit_app.py': 'punto_entrada_streamlit.py',            'requirements.txt': 'requirements_actualizado.txt',            'run_progol_engine_v2.py': 'pipeline_integracion.py'        }                self.new_directories = [            'data/outputs',            'data/backups',             'data/templates',            'logs',            'models/cache'        ]            def run_update(self) -> bool:        """Ejecutar actualizaci√≥n completa"""        logger.info("üîÑ INICIANDO ACTUALIZACI√ìN DEL DASHBOARD")        logger.info("=" * 50)                try:            # 1. Verificar estado actual            if not self._verify_current_installation():                logger.error("‚ùå La instalaci√≥n actual no es compatible")                return False                        # 2. Crear backup si est√° habilitado            if self.backup_enabled:                if not self._create_backup():                    logger.error("‚ùå Error creando backup")                    return False                        # 3. Crear nuevos directorios            self._create_new_directories()                        # 4. Actualizar archivos existentes            updated_files = self._update_existing_files()                        # 5. Agregar nuevos archivos            new_files = self._add_new_files()                        # 6. Actualizar configuraciones            self._update_configurations()                        # 7. Migrar datos existentes            self._migrate_existing_data()                        # 8. Validar actualizaci√≥n            if not self._validate_update():                logger.error("‚ùå Validaci√≥n de actualizaci√≥n fall√≥")                return False                        # 9. Mostrar resumen            self._show_update_summary(updated_files, new_files)                        logger.info("‚úÖ ACTUALIZACI√ìN COMPLETADA EXITOSAMENTE")            return True                    except Exception as e:            logger.error(f"‚ùå Error durante actualizaci√≥n: {e}")                        # Intentar restaurar backup si existe            if self.backup_enabled and self.backup_dir:                logger.info("üîÑ Intentando restaurar desde backup...")                self._restore_from_backup()                        return False        def _verify_current_installation(self) -> bool:        """Verificar instalaci√≥n actual"""        logger.info("üîç Verificando instalaci√≥n actual...")                # Verificar archivos cr√≠ticos existentes        critical_files = [            'streamlit_app/dashboard.py',            'src/utils/config.py',            'requirements.txt'        ]                missing_files = []        for file_path in critical_files:            if not Path(file_path).exists():                missing_files.append(file_path)                if missing_files:            logger.warning(f"‚ö†Ô∏è Archivos cr√≠ticos faltantes: {missing_files}")                        # Preguntar si continuar            response = input("¬øContinuar con la actualizaci√≥n? (y/N): ")            if response.lower() != 'y':                return False                # Verificar versi√≥n de Python        if sys.version_info < (3, 8):            logger.error(f"‚ùå Python 3.8+ requerido, encontrado {sys.version_info.major}.{sys.version_info.minor}")            return False                logger.info("‚úÖ Instalaci√≥n actual verificada")        return True        def _create_backup(self) -> bool:        """Crear backup de la instalaci√≥n actual"""        logger.info("üíæ Creando backup...")                backup_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")        self.backup_dir = Path(f"backup_progol_{backup_timestamp}")                try:            self.backup_dir.mkdir(exist_ok=True)                        # Backup de archivos cr√≠ticos            files_to_backup = [                'streamlit_app/',                'src/',                'data/',                'requirements.txt',                '.env',                'setup.py'            ]                        backed_up_files = 0            for item in files_to_backup:                source_path = Path(item)                if source_path.exists():                    dest_path = self.backup_dir / item                                        if source_path.is_dir():                        shutil.copytree(source_path, dest_path, dirs_exist_ok=True)                    else:                        dest_path.parent.mkdir(parents=True, exist_ok=True)                        shutil.copy2(source_path, dest_path)                                        backed_up_files += 1                        logger.info(f"‚úÖ Backup creado: {self.backup_dir} ({backed_up_files} elementos)")            return True                    except Exception as e:            logger.error(f"‚ùå Error creando backup: {e}")            return False        def _create_new_directories(self):        """Crear nuevos directorios necesarios"""        logger.info("üìÅ Creando nuevos directorios...")                created_dirs = 0        for directory in self.new_directories:            dir_path = Path(directory)            if not dir_path.exists():                dir_path.mkdir(parents=True, exist_ok=True)                created_dirs += 1                logger.info(f"   ‚úÖ Creado: {directory}")                logger.info(f"üìÅ {created_dirs} nuevos directorios creados")        def _update_existing_files(self) -> List[str]:        """Actualizar archivos existentes"""        logger.info("üìù Actualizando archivos existentes...")                updated_files = []                for target_file, source_content in self.files_to_update.items():            target_path = Path(target_file)                        if target_path.exists():                # Hacer backup del archivo original                backup_path = target_path.with_suffix(f'{target_path.suffix}.backup')                shutil.copy2(target_path, backup_path)                                # Determinar c√≥mo actualizar seg√∫n el archivo                if target_file == 'streamlit_app/dashboard.py':                    success = self._update_dashboard_file(target_path)                elif target_file == 'src/utils/config.py':                    success = self._update_config_file(target_path)                elif target_file == 'requirements.txt':                    success = self._update_requirements_file(target_path)                else:                    success = self._update_generic_file(target_path, source_content)                                if success:                    updated_files.append(target_file)                    logger.info(f"   ‚úÖ Actualizado: {target_file}")                else:                    # Restaurar desde backup                    shutil.copy2(backup_path, target_path)                    logger.warning(f"   ‚ö†Ô∏è Error actualizando: {target_file} (restaurado)")            else:                logger.info(f"   ‚ûï Archivo nuevo: {target_file}")                return updated_files        def _update_dashboard_file(self, target_path: Path) -> bool:        """Actualizar archivo del dashboard espec√≠ficamente"""        try:            # Leer contenido actual            with open(target_path, 'r', encoding='utf-8') as f:                current_content = f.read()                        # Detectar si ya tiene las mejoras v2            if 'Progol Engine v2' in current_content:                logger.info("   ‚ÑπÔ∏è Dashboard ya parece estar actualizado")                return True                        # Preservar configuraciones personalizadas si existen            custom_configs = self._extract_custom_configurations(current_content)                        # Aqu√≠ ir√≠a la l√≥gica para integrar el nuevo dashboard            # Por ahora, creamos un archivo de migraci√≥n            migration_content = self._create_dashboard_migration_template(custom_configs)                        # Escribir el archivo de migraci√≥n            migration_path = target_path.parent / 'dashboard_v2_migration.py'            with open(migration_path, 'w', encoding='utf-8') as f:                f.write(migration_content)                        logger.info(f"   üìã Template de migraci√≥n creado: {migration_path}")            return True                    except Exception as e:            logger.error(f"   ‚ùå Error actualizando dashboard: {e}")            return False        def _update_config_file(self, target_path: Path) -> bool:        """Actualizar archivo de configuraci√≥n"""        try:            # Leer configuraci√≥n actual            with open(target_path, 'r', encoding='utf-8') as f:                current_content = f.read()                        # Extraer variables personalizadas            custom_vars = self._extract_custom_variables(current_content)                        # Crear configuraci√≥n h√≠brida            hybrid_config = self._create_hybrid_config(custom_vars)                        # Escribir nuevo archivo de configuraci√≥n            config_v2_path = target_path.parent / 'config_v2.py'            with open(config_v2_path, 'w', encoding='utf-8') as f:                f.write(hybrid_config)                        logger.info(f"   üìã Configuraci√≥n v2 creada: {config_v2_path}")            return True                    except Exception as e:            logger.error(f"   ‚ùå Error actualizando configuraci√≥n: {e}")            return False        def _update_requirements_file(self, target_path: Path) -> bool:        """Actualizar archivo de dependencias"""        try:            # Leer requirements actual            with open(target_path, 'r', encoding='utf-8') as f:                current_requirements = f.read()                        # Dependencias nuevas cr√≠ticas            new_requirements = [                "# === NUEVAS DEPENDENCIAS PROGOL ENGINE V2 ===",                "PyMuPDF>=1.23.0  # Procesamiento avanzado de PDFs",                "pydantic>=2.0.0  # Validaci√≥n de datos",                "joblib>=1.3.0    # Procesamiento paralelo",                "statsmodels>=0.14.0  # Estad√≠sticas avanzadas",                "",                "# === DEPENDENCIAS ORIGINALES ===",                current_requirements            ]                        # Escribir requirements actualizado            with open(target_path, 'w', encoding='utf-8') as f:                f.write('\n'.join(new_requirements))                        return True                    except Exception as e:            logger.error(f"   ‚ùå Error actualizando requirements: {e}")            return False        def _update_generic_file(self, target_path: Path, source_content: str) -> bool:        """Actualizar archivo gen√©rico"""        try:            # Para archivos gen√©ricos, crear una copia con sufijo _v2            new_path = target_path.parent / f"{target_path.stem}_v2{target_path.suffix}"                        # Aqu√≠ ir√≠a el contenido del archivo nuevo            # Por ahora, crear un placeholder            placeholder_content = f"""# {target_path.name} - Versi√≥n 2.0# Archivo actualizado para Progol Engine v2# # Este archivo contiene las mejoras para el sistema v2# Revisar e integrar con la versi√≥n original## Archivo original respaldado como: {target_path.name}.backup# TODO: Integrar contenido de {source_content}"""                        with open(new_path, 'w', encoding='utf-8') as f:                f.write(placeholder_content)                        return True                    except Exception as e:            logger.error(f"   ‚ùå Error actualizando archivo gen√©rico: {e}")            return False        def _add_new_files(self) -> List[str]:        """Agregar nuevos archivos al sistema"""        logger.info("‚ûï Agregando nuevos archivos...")                new_files = []                # Archivos nuevos a crear        new_files_to_create = {            'run_progol_engine_v2.py': self._get_main_pipeline_template(),            'src/utils/template_generator.py': self._get_template_generator_template(),            'scripts/migrate_to_v2.py': self._get_migration_script_template(),            'docs/UPGRADE_GUIDE.md': self._get_upgrade_guide_template(),            '.streamlit/config_v2.toml': self._get_streamlit_config_template()        }                for file_path, content in new_files_to_create.items():            target_path = Path(file_path)            target_path.parent.mkdir(parents=True, exist_ok=True)                        try:                with open(target_path, 'w', encoding='utf-8') as f:                    f.write(content)                                new_files.append(file_path)                logger.info(f"   ‚úÖ Creado: {file_path}")                            except Exception as e:                logger.warning(f"   ‚ö†Ô∏è Error creando {file_path}: {e}")                return new_files        def _update_configurations(self):        """Actualizar configuraciones del sistema"""        logger.info("‚öôÔ∏è Actualizando configuraciones...")                # Actualizar .env si existe        env_path = Path('.env')        if env_path.exists():            self._update_env_file(env_path)                # Crear configuraci√≥n de Streamlit v2        streamlit_config_path = Path('.streamlit/config_v2.toml')        streamlit_config_path.parent.mkdir(exist_ok=True)                with open(streamlit_config_path, 'w', encoding='utf-8') as f:            f.write(self._get_streamlit_config_template())        def _migrate_existing_data(self):        """Migrar datos existentes al nuevo formato"""        logger.info("üìä Migrando datos existentes...")                # Migrar datos de processed a nuevo formato        processed_dir = Path('data/processed')        if processed_dir.exists():            files_migrated = 0            for file_path in processed_dir.glob('*.csv'):                try:                    # Crear copia de seguridad y validar formato                    backup_path = file_path.with_suffix('.csv.v1_backup')                    shutil.copy2(file_path, backup_path)                    files_migrated += 1                except Exception as e:                    logger.warning(f"   ‚ö†Ô∏è Error migrando {file_path}: {e}")                        logger.info(f"   üìä {files_migrated} archivos respaldados")        def _validate_update(self) -> bool:        """Validar que la actualizaci√≥n fue exitosa"""        logger.info("‚úì Validando actualizaci√≥n...")                # Verificar archivos cr√≠ticos nuevos        critical_new_files = [            'run_progol_engine_v2.py',            'docs/UPGRADE_GUIDE.md'        ]                missing_files = []        for file_path in critical_new_files:            if not Path(file_path).exists():                missing_files.append(file_path)                if missing_files:            logger.error(f"   ‚ùå Archivos cr√≠ticos faltantes: {missing_files}")            return False                # Verificar que las dependencias son importables        try:            import pandas            import numpy            import streamlit            logger.info("   ‚úÖ Dependencias b√°sicas verificadas")        except ImportError as e:            logger.error(f"   ‚ùå Error importando dependencias: {e}")            return False                return True        def _restore_from_backup(self) -> bool:        """Restaurar desde backup en caso de error"""        if not self.backup_dir or not self.backup_dir.exists():            logger.error("‚ùå No hay backup disponible para restaurar")            return False                try:            logger.info(f"üîÑ Restaurando desde backup: {self.backup_dir}")                        # Restaurar archivos cr√≠ticos            for item in self.backup_dir.iterdir():                target_path = Path(item.name)                                if item.is_dir():                    if target_path.exists():                        shutil.rmtree(target_path)                    shutil.copytree(item, target_path)                else:                    shutil.copy2(item, target_path)                        logger.info("‚úÖ Restauraci√≥n desde backup completada")            return True                    except Exception as e:            logger.error(f"‚ùå Error restaurando backup: {e}")            return False        def _show_update_summary(self, updated_files: List[str], new_files: List[str]):        """Mostrar resumen de la actualizaci√≥n"""        logger.info("\n" + "=" * 60)        logger.info("üìã RESUMEN DE ACTUALIZACI√ìN")        logger.info("=" * 60)                logger.info(f"üìù Archivos actualizados: {len(updated_files)}")        for file_path in updated_files:            logger.info(f"   ‚úèÔ∏è {file_path}")                logger.info(f"\n‚ûï Archivos nuevos: {len(new_files)}")        for file_path in new_files:            logger.info(f"   üìÑ {file_path}")                if self.backup_dir:            logger.info(f"\nüíæ Backup disponible en: {self.backup_dir}")                logger.info("\nüìö PR√ìXIMOS PASOS:")        logger.info("1. Revisar archivos con sufijo _v2 o _migration")        logger.info("2. Leer docs/UPGRADE_GUIDE.md para instrucciones detalladas")        logger.info("3. Ejecutar: pip install -r requirements.txt")        logger.info("4. Probar: python run_progol_engine_v2.py --help")        logger.info("5. Iniciar dashboard: streamlit run streamlit_app.py")                logger.info("=" * 60)        # === TEMPLATES DE ARCHIVOS NUEVOS ===        def _get_main_pipeline_template(self) -> str:        """Template del pipeline principal"""        return '''#!/usr/bin/env python3"""Pipeline Principal - Progol Engine v2Este archivo contiene el pipeline principal mejorado"""import sysfrom pathlib import Path# Agregar al pathsys.path.insert(0, str(Path(__file__).parent))def main():    """Funci√≥n principal"""    print("üî¢ Progol Engine v2 - Pipeline Principal")    print("Para funcionalidad completa, revisar archivo de integraci√≥n completo")    print("Ejecutar: python -c 'from run_progol_engine_v2 import main; main()'")if __name__ == "__main__":    main()'''        def _get_template_generator_template(self) -> str:        """Template del generador de templates"""        return '''#!/usr/bin/env python3"""Generador de Templates - Progol Engine v2"""import pandas as pdimport numpy as npdef generate_progol_template(n_partidos=21):    """Generar template de Progol.csv"""    data = []    for i in range(n_partidos):        data.append({            'jornada': '',            'partido': i + 1,            'tipo': 'Regular' if i < 14 else 'Revancha',            'local': '',            'visitante': '',            'goles_local': '',            'goles_visitante': ''        })        return pd.DataFrame(data)if __name__ == "__main__":    template = generate_progol_template()    template.to_csv('progol_template.csv', index=False)    print("‚úÖ Template generado: progol_template.csv")'''        def _get_migration_script_template(self) -> str:        """Template del script de migraci√≥n"""        return '''#!/usr/bin/env python3"""Script de Migraci√≥n - Progol Engine v2Ayuda a migrar datos del sistema v1 al v2"""import pandas as pdfrom pathlib import Pathdef migrate_portfolio_data():    """Migrar datos de portafolio"""    print("üîÑ Migrando datos de portafolio...")        # Buscar archivos de portafolio v1    processed_dir = Path('data/processed')    if not processed_dir.exists():        print("‚ùå Directorio data/processed no encontrado")        return        portfolio_files = list(processed_dir.glob('portfolio*.csv'))        for file_path in portfolio_files:        try:            df = pd.read_csv(file_path)                        # Verificar si ya tiene formato v2            if 'tipo' in df.columns:                print(f"‚úÖ {file_path.name} ya en formato v2")                continue                        # Agregar columna tipo si no existe            if 'quiniela_id' in df.columns:                df['tipo'] = df['quiniela_id'].apply(                    lambda x: 'Core' if x.startswith('C') else 'Sat√©lite'                )                        # Guardar versi√≥n migrada            migrated_path = file_path.parent / f"migrated_{file_path.name}"            df.to_csv(migrated_path, index=False)            print(f"‚úÖ Migrado: {file_path.name} -> {migrated_path.name}")                    except Exception as e:            print(f"‚ùå Error migrando {file_path}: {e}")if __name__ == "__main__":    migrate_portfolio_data()'''        def _get_upgrade_guide_template(self) -> str:        """Template de la gu√≠a de actualizaci√≥n"""        return '''# Gu√≠a de Actualizaci√≥n - Progol Engine v2## üéØ Nuevas Funcionalidades### Soporte para Revancha- Ahora soporta hasta 21 partidos (14 regulares + 7 revancha)- Configuraci√≥n flexible del n√∫mero de partidos### UI Mejorada- Dashboard m√°s intuitivo- Resultados disponibles directamente en la app- Mejor gesti√≥n de archivos### Optimizador Avanzado- Algoritmo GRASP mejorado- Arquitectura Core + Sat√©lites optimizada- Simulaci√≥n Monte Carlo m√°s precisa## üìã Pasos de Migraci√≥n### 1. Backup Completado‚úÖ Tu instalaci√≥n anterior ha sido respaldada autom√°ticamente### 2. Archivos Nuevos Creados- `run_progol_engine_v2.py` - Pipeline principal- `streamlit_app/dashboard_v2_migration.py` - Dashboard mejorado- `src/utils/config_v2.py` - Configuraci√≥n actualizada### 3. Pr√≥ximos Pasos#### Instalar Nuevas Dependencias```bashpip install -r requirements.txt```#### Probar Pipeline v2```bashpython run_progol_engine_v2.py --jornada 2283 --help```#### Migrar Dashboard1. Revisar `streamlit_app/dashboard_v2_migration.py`2. Integrar configuraciones personalizadas3. Probar con: `streamlit run streamlit_app.py`#### Migrar Datos Existentes```bashpython scripts/migrate_to_v2.py```## üîß Configuraci√≥n### Variables de Entorno NuevasAgregar a tu archivo `.env`:```# Configuraci√≥n v2PARTIDOS_REGULARES=14PARTIDOS_REVANCHA_MAX=7STREAMLIT_V2_ENABLED=true```## ‚ö†Ô∏è Problemas Conocidos### Dashboard Original- El dashboard original seguir√° funcionando- Para nuevas funcionalidades, usar archivos _v2### Datos Existentes- Los datos existentes son compatibles- Ejecutar migraci√≥n para mejor rendimiento## üìû SoporteSi encuentras problemas:1. Revisar logs en `logs/progol_engine_v2.log`2. Restaurar backup si es necesario3. Consultar documentaci√≥n t√©cnica---*Generado autom√°ticamente por el actualizador de Progol Engine v2*'''        def _get_streamlit_config_template(self) -> str:        """Template de configuraci√≥n de Streamlit"""        return '''[theme]primaryColor = "#2ecc71"backgroundColor = "#ffffff"secondaryBackgroundColor = "#f0f2f6"textColor = "#262730"font = "sans serif"[server]headless = trueport = 8501maxUploadSize = 200enableCORS = falseenableXsrfProtection = true[browser]gatherUsageStats = falseshowErrorDetails = true# Configuraci√≥n espec√≠fica para v2[global]developmentMode = falsedataFrameSerialization = "arrow"[runner]magicEnabled = trueinstallTracer = falsefixMatplotlib = true'''        # === M√âTODOS AUXILIARES ===        def _extract_custom_configurations(self, content: str) -> Dict:        """Extraer configuraciones personalizadas del dashboard"""        # Implementar extracci√≥n de configuraciones        return {}        def _extract_custom_variables(self, content: str) -> Dict:        """Extraer variables personalizadas de config.py"""        # Implementar extracci√≥n de variables        return {}        def _create_dashboard_migration_template(self, custom_configs: Dict) -> str:        """Crear template de migraci√≥n del dashboard"""        return f'''#!/usr/bin/env python3"""Template de Migraci√≥n del DashboardConfiguraciones personalizadas detectadas: {len(custom_configs)}"""# TODO: Integrar con el dashboard mejorado# Las configuraciones personalizadas se han preservado# Revisar y aplicar seg√∫n sea necesarioprint("üìã Template de migraci√≥n del dashboard")print("Revisar archivo dashboard mejorado e integrar configuraciones")'''        def _create_hybrid_config(self, custom_vars: Dict) -> str:        """Crear configuraci√≥n h√≠brida"""        return f'''#!/usr/bin/env python3"""Configuraci√≥n H√≠brida - Progol Engine v2Variables personalizadas preservadas: {len(custom_vars)}"""# Configuraci√≥n base v2from .config_v2_base import *# Variables personalizadas preservadas{chr(10).join(f"{k} = {repr(v)}" for k, v in custom_vars.items())}# TODO: Revisar e integrar configuraciones personalizadas'''        def _update_env_file(self, env_path: Path):        """Actualizar archivo .env"""        try:            with open(env_path, 'r') as f:                content = f.read()                        # Agregar variables v2 si no existen            new_vars = [                "",                "# === PROGOL ENGINE V2 ===",                "PARTIDOS_REGULARES=14",                "PARTIDOS_REVANCHA_MAX=7",                 "STREAMLIT_V2_ENABLED=true",                "PROGOL_ENGINE_VERSION=2.0.0"            ]                        if "PROGOL_ENGINE_VERSION" not in content:                with open(env_path, 'a') as f:                    f.write('\n'.join(new_vars))                            except Exception as e:            logger.warning(f"Error actualizando .env: {e}")def main():    """Funci√≥n principal del actualizador"""    print("üî¢ Progol Engine v2 - Actualizador de Dashboard")    print("=" * 50)        # Preguntar confirmaci√≥n    response = input("¬øProceder con la actualizaci√≥n? (y/N): ")    if response.lower() != 'y':        print("‚ùå Actualizaci√≥n cancelada")        return        # Crear actualizador    updater = DashboardUpdater(backup=True)        # Ejecutar actualizaci√≥n    success = updater.run_update()        if success:        print("\nüéâ ¬°Actualizaci√≥n completada exitosamente!")        print("üìö Revisa docs/UPGRADE_GUIDE.md para los pr√≥ximos pasos")    else:        print("\n‚ùå La actualizaci√≥n fall√≥")        print("üíæ Revisa si hay backups disponibles")if __name__ == "__main__":    main()