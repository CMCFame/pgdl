#!/usr/bin/env python3"""Generador de Quinielas M√∫ltiples - Integraci√≥n con Metodolog√≠a DefinitivaMantiene 100% compatibilidad con el sistema actualEste m√≥dulo extiende la funcionalidad existente sin modificar el core engine."""import loggingimport numpy as npfrom typing import List, Dict, Tuple, Optionalfrom dataclasses import dataclassimport mathimport pandas as pdlogger = logging.getLogger(__name__)@dataclassclass PartidoMultiple:    """Representaci√≥n de un partido con m√∫ltiples opciones"""    numero: int    opciones: List[str]  # ['L'], ['L','V'], ['L','E','V']    probabilidades: Dict[str, float]  # {'L': 0.45, 'E': 0.30, 'V': 0.25}    clasificacion: str  # 'Ancla', 'Divisor', 'TendenciaX', 'Neutro'    valor_multiple: float = 0.0  # Valor calculado para ser m√∫ltiple        @property    def tipo(self) -> str:        """Determinar tipo basado en n√∫mero de opciones"""        if len(self.opciones) == 1:            return "sencillo"        elif len(self.opciones) == 2:            return "doble"        elif len(self.opciones) == 3:            return "triple"        else:            return "multiple"@dataclassclass QuinielaMultiple:    """Quiniela compacta con m√∫ltiples opciones por partido"""    partidos: List[PartidoMultiple]        @property    def combinaciones_totales(self) -> int:        """Calcular n√∫mero total de combinaciones"""        total = 1        for partido in self.partidos:            total *= len(partido.opciones)        return total        @property    def costo_total(self) -> float:        """Calcular costo total (asumiendo $15 MXN por quiniela)"""        return self.combinaciones_totales * 15.0        @property    def resumen(self) -> Dict:        """Resumen de la configuraci√≥n"""        sencillos = len([p for p in self.partidos if p.tipo == "sencillo"])        dobles = len([p for p in self.partidos if p.tipo == "doble"])        triples = len([p for p in self.partidos if p.tipo == "triple"])                return {            'sencillos': sencillos,            'dobles': dobles,            'triples': triples,            'combinaciones_totales': self.combinaciones_totales,            'costo_total': self.costo_total        }class ValorMultipleCalculator:    """Calculadora de valor para determinar d√≥nde colocar dobles/triples"""        @staticmethod    def calcular_valor_doble(partido_probs: Dict[str, float], clasificacion: str) -> float:        """        Calcula qu√© tan valioso es convertir este partido en doble                Args:            partido_probs: {'L': 0.45, 'E': 0.30, 'V': 0.25}            clasificacion: 'Ancla', 'Divisor', 'TendenciaX', 'Neutro'                Returns:            float: Valor entre 0-1 (mayor = m√°s valioso)        """        p_L, p_E, p_V = partido_probs['L'], partido_probs['E'], partido_probs['V']                # Las dos opciones m√°s probables        probabilidades_ordenadas = sorted([p_L, p_E, p_V], reverse=True)        valor_base = probabilidades_ordenadas[0] + probabilidades_ordenadas[1]                # Bonus por clasificaci√≥n        bonus = 0.0        if clasificacion == "Divisor":  # 0.40 < p_max < 0.60            bonus += 0.15        elif clasificacion == "TendenciaX":            bonus += 0.10        elif clasificacion == "Ancla":  # Muy confiable, menos valioso para doble            bonus -= 0.20                    # Penalty si una opci√≥n domina demasiado        if probabilidades_ordenadas[0] > 0.65:            bonus -= 0.15                    return max(0.0, min(1.0, valor_base + bonus))        @staticmethod    def calcular_valor_triple(partido_probs: Dict[str, float], clasificacion: str) -> float:        """        Calcula qu√© tan valioso es convertir este partido en triple                Args:            partido_probs: {'L': 0.45, 'E': 0.30, 'V': 0.25}            clasificacion: 'Ancla', 'Divisor', 'TendenciaX', 'Neutro'                Returns:            float: Valor entre 0-1 (mayor = m√°s valioso)        """        p_L, p_E, p_V = partido_probs['L'], partido_probs['E'], partido_probs['V']                # Triple es valioso cuando las probabilidades est√°n parejas        varianza = np.var([p_L, p_E, p_V])        valor_base = 1 / (1 + varianza * 10)  # Menor varianza = mayor valor                # Bonus por clasificaci√≥n        bonus = 0.0        if clasificacion == "Divisor":            bonus += 0.20        elif clasificacion == "TendenciaX" and p_E > 0.25:  # Empate probable            bonus += 0.15        elif clasificacion == "Ancla":  # Muy confiable, malo para triple            bonus -= 0.30                    return max(0.0, min(1.0, valor_base + bonus))class MultipleQuinielasGenerator:    """    Generador inteligente de quinielas m√∫ltiples    Integra con la Metodolog√≠a Definitiva existente    """        def __init__(self):        self.calculator = ValorMultipleCalculator()            def generar_quiniela_multiple(self,                                 matches_data: List[Dict],                                 num_dobles: int = 0,                                 num_triples: int = 0,                                overrides: Optional[Dict[int, List[str]]] = None) -> QuinielaMultiple:        """        Genera una quiniela m√∫ltiple inteligente                Args:            matches_data: Lista de diccionarios con datos de partidos                Formato: [{'numero': 1, 'prob_l': 0.45, 'prob_e': 0.30, 'prob_v': 0.25, 'clasificacion': 'Divisor'}, ...]            num_dobles: N√∫mero de dobles deseados            num_triples: N√∫mero de triples deseados              overrides: Configuraci√≥n manual por partido {partido_num: ['L', 'V']}                    Returns:            QuinielaMultiple: Quiniela configurada autom√°ticamente        """        logger.info(f"Generando quiniela m√∫ltiple: {num_dobles} dobles, {num_triples} triples")                # 1. Convertir datos y calcular valores para m√∫ltiples        candidatos_dobles = []        candidatos_triples = []                for match in matches_data:            num_partido = match['numero']            probs = {                'L': match['prob_l'],                'E': match['prob_e'],                 'V': match['prob_v']            }            clasificacion = match['clasificacion']                        # Calcular valores            valor_doble = self.calculator.calcular_valor_doble(probs, clasificacion)            valor_triple = self.calculator.calcular_valor_triple(probs, clasificacion)                        candidatos_dobles.append((num_partido - 1, valor_doble, probs, clasificacion))            candidatos_triples.append((num_partido - 1, valor_triple, probs, clasificacion))                # 2. Seleccionar mejores candidatos        mejores_triples = sorted(candidatos_triples, key=lambda x: x[1], reverse=True)[:num_triples]        mejores_dobles = sorted(candidatos_dobles, key=lambda x: x[1], reverse=True)[:num_dobles]                # Evitar solapamiento (si un partido es triple, no puede ser doble)        partidos_triple = {idx for idx, _, _, _ in mejores_triples}        mejores_dobles = [(idx, val, probs, clas) for idx, val, probs, clas in mejores_dobles                          if idx not in partidos_triple][:num_dobles]                # 3. Construir partidos m√∫ltiples        partidos = []                for i, match in enumerate(matches_data):            probs = {                'L': match['prob_l'],                'E': match['prob_e'],                 'V': match['prob_v']            }            clasificacion = match['clasificacion']                        # Verificar override manual            if overrides and i in overrides:                opciones = overrides[i]                valor_multiple = 1.0  # Override tiene prioridad m√°xima                            # Verificar si debe ser triple            elif i in partidos_triple:                opciones = self._generar_opciones_triple(probs, clasificacion)                valor_multiple = next(val for idx, val, _, _ in mejores_triples if idx == i)                            # Verificar si debe ser doble            elif any(idx == i for idx, _, _, _ in mejores_dobles):                opciones = self._generar_opciones_doble(probs, clasificacion)                valor_multiple = next(val for idx, val, _, _ in mejores_dobles if idx == i)                            # Caso por defecto: sencillo            else:                opciones = [self._obtener_mejor_opcion(probs)]                valor_multiple = 0.0                        partido = PartidoMultiple(                numero=i + 1,                opciones=opciones,                probabilidades=probs,                clasificacion=clasificacion,                valor_multiple=valor_multiple            )            partidos.append(partido)                quiniela = QuinielaMultiple(partidos=partidos)                # 4. Validar y ajustar si es necesario        self._validar_y_ajustar(quiniela)                logger.info(f"Quiniela generada: {quiniela.resumen}")        return quiniela        def _generar_opciones_doble(self, probs: Dict[str, float], clasificacion: str) -> List[str]:        """Generar opciones para un doble inteligentemente"""        p_L, p_E, p_V = probs['L'], probs['E'], probs['V']                # L√≥gica espec√≠fica por clasificaci√≥n        if clasificacion == "TendenciaX" and p_E > 0.25:            # Incluir empate + mejor resultado            mejor_resultado = 'L' if p_L > p_V else 'V'            return ['E', mejor_resultado]                elif abs(p_L - p_V) < 0.08:  # Muy cerrado entre L y V            return ['L', 'V']                else:            # Las dos opciones m√°s probables            opciones_ordenadas = sorted(['L', 'E', 'V'], key=lambda x: probs[x], reverse=True)            return opciones_ordenadas[:2]        def _generar_opciones_triple(self, probs: Dict[str, float], clasificacion: str) -> List[str]:        """Generar opciones para un triple (siempre todas las opciones)"""        return ['L', 'E', 'V']        def _obtener_mejor_opcion(self, probs: Dict[str, float]) -> str:        """Obtener la opci√≥n m√°s probable"""        return max(['L', 'E', 'V'], key=lambda x: probs[x])        def _validar_y_ajustar(self, quiniela: QuinielaMultiple):        """Validar y ajustar quiniela seg√∫n reglas de la metodolog√≠a"""                # Validar l√≠mites de costo (ejemplo: m√°ximo 5000 quinielas)        if quiniela.combinaciones_totales > 5000:            logger.warning(f"Demasiadas combinaciones ({quiniela.combinaciones_totales}), ajustando...")            self._reducir_complejidad(quiniela)                # Validar que tengamos al menos algunos empates probables        empates_incluidos = sum(1 for p in quiniela.partidos if 'E' in p.opciones)        if empates_incluidos < 3:            logger.info("Ajustando para incluir m√°s empates...")            self._incluir_mas_empates(quiniela)        def _reducir_complejidad(self, quiniela: QuinielaMultiple):        """Reducir complejidad convirtiendo algunos triples en dobles"""        # Convertir el triple con menor valor a doble        triples = [(i, p) for i, p in enumerate(quiniela.partidos) if p.tipo == "triple"]        if triples:            idx, partido = min(triples, key=lambda x: x[1].valor_multiple)            new_opciones = self._generar_opciones_doble(partido.probabilidades, partido.clasificacion)            quiniela.partidos[idx].opciones = new_opciones            logger.info(f"Partido {idx+1} convertido de triple a doble")        def _incluir_mas_empates(self, quiniela: QuinielaMultiple):        """Incluir m√°s empates en partidos propensos"""        for partido in quiniela.partidos:            if (partido.tipo == "sencillo" and                 partido.probabilidades['E'] > 0.20 and                 'E' not in partido.opciones):                # Convertir a doble incluyendo empate                mejor_resultado = self._obtener_mejor_opcion(partido.probabilidades)                partido.opciones = ['E', mejor_resultado]                logger.info(f"Partido {partido.numero} ajustado para incluir empate")                break# Funciones de utilidad para integraci√≥n con la app existentedef calcular_presupuesto(num_dobles: int, num_triples: int, num_partidos: int = 14) -> Dict:    """    Calcular presupuesto aproximado para una configuraci√≥n de m√∫ltiples        Returns:        Dict con combinaciones aproximadas y costo    """    # Estimaci√≥n conservadora (asume que dobles y triples se colocan estrat√©gicamente)    combinaciones_dobles = 2 ** min(num_dobles, 8)  # L√≠mite realista    combinaciones_triples = 3 ** min(num_triples, 3)  # L√≠mite realista        # Los dem√°s partidos son sencillos    partidos_sencillos = num_partidos - num_dobles - num_triples    combinaciones_sencillos = 1 ** partidos_sencillos        total_combinaciones = combinaciones_dobles * combinaciones_triples * combinaciones_sencillos    costo_total = total_combinaciones * 15.0        return {        'combinaciones_aproximadas': total_combinaciones,        'costo_total': costo_total,        'costo_formateado': f"${costo_total:,.0f}"    }def validar_configuracion(num_dobles: int, num_triples: int) -> Tuple[bool, str]:    """    Validar que la configuraci√≥n sea razonable        Returns:        (es_valida, mensaje)    """    if num_dobles < 0 or num_triples < 0:        return False, "‚ùå N√∫mero de dobles/triples no puede ser negativo"        if num_dobles + num_triples > 14:        return False, "‚ùå No puedes tener m√°s m√∫ltiples que partidos"        presupuesto = calcular_presupuesto(num_dobles, num_triples)    if presupuesto['combinaciones_aproximadas'] > 10000:        return False, f"‚ö†Ô∏è Demasiadas combinaciones ({presupuesto['combinaciones_aproximadas']:,}). Reduce dobles/triples."        if presupuesto['costo_total'] > 50000:        return False, f"üí∞ Costo muy alto ({presupuesto['costo_formateado']}). Considera reducir."        return True, "‚úÖ Configuraci√≥n v√°lida"# Funciones de integraci√≥n con datos existentesdef convertir_matches_data(df_prob, df_classification=None):    """    Convertir datos existentes al formato requerido por MultipleQuinielasGenerator        Args:        df_prob: DataFrame con probabilidades (formato actual de la app)        df_classification: DataFrame con clasificaciones (opcional)        Returns:        List[Dict]: Datos formateados para el generador    """    # DEBUG: Mostrar qu√© columnas est√°n disponibles    print("=== DEBUG: Columnas disponibles en df_prob ===")    print("Columnas:", list(df_prob.columns))    print("Primera fila:", df_prob.iloc[0].to_dict() if len(df_prob) > 0 else "Sin datos")        matches_data = []        for i, row in df_prob.iterrows():        # Buscar probabilidades con m√∫ltiples variantes de nombres        columnas_l = ['prob_l', 'P_L', 'p_final_L', 'p_blend_L']        columnas_e = ['prob_e', 'P_E', 'p_final_E', 'p_blend_E']        columnas_v = ['prob_v', 'P_V', 'p_final_V', 'p_blend_V']                # Encontrar la primera columna que existe        prob_l = None        for col in columnas_l:            if col in row and not pd.isna(row[col]):                prob_l = row[col]                if i == 0:  # Solo log para el primer partido                    print(f"DEBUG: Usando columna '{col}' para prob_L = {prob_l}")                break                prob_e = None        for col in columnas_e:            if col in row and not pd.isna(row[col]):                prob_e = row[col]                if i == 0:                    print(f"DEBUG: Usando columna '{col}' para prob_E = {prob_e}")                break                        prob_v = None        for col in columnas_v:            if col in row and not pd.isna(row[col]):                prob_v = row[col]                if i == 0:                    print(f"DEBUG: Usando columna '{col}' para prob_V = {prob_v}")                break                # Fallback a 0.33 si no se encontr√≥ nada        prob_l = prob_l if prob_l is not None else 0.33        prob_e = prob_e if prob_e is not None else 0.33        prob_v = prob_v if prob_v is not None else 0.33                if i == 0:            print(f"DEBUG: Probabilidades finales para partido 1: L={prob_l}, E={prob_e}, V={prob_v}")                match_data = {            'numero': i + 1,            'prob_l': float(prob_l),            'prob_e': float(prob_e),            'prob_v': float(prob_v),            'clasificacion': 'Neutro'  # Default        }                # Agregar clasificaci√≥n si est√° disponible        if df_classification is not None and i < len(df_classification):            match_data['clasificacion'] = df_classification.iloc[i].get('clasificacion', 'Neutro')        else:            # Clasificar basado en probabilidades            p_max = max(prob_l, prob_e, prob_v)            if p_max > 0.60:                match_data['clasificacion'] = 'Ancla'            elif 0.40 < p_max < 0.60:                match_data['clasificacion'] = 'Divisor'            elif prob_e > 0.30:                match_data['clasificacion'] = 'TendenciaX'                matches_data.append(match_data)        print(f"=== DEBUG: Convertidos {len(matches_data)} partidos ===")    return matches_data