#!/usr/bin/env python3"""Generador de Quinielas Múltiples - Integración con Metodología DefinitivaMantiene 100% compatibilidad con el sistema actualEste módulo extiende la funcionalidad existente sin modificar el core engine."""import loggingimport numpy as npfrom typing import List, Dict, Tuple, Optionalfrom dataclasses import dataclassimport mathimport pandas as pdlogger = logging.getLogger(__name__)@dataclassclass PartidoMultiple:    """Representación de un partido con múltiples opciones"""    numero: int    opciones: List[str]  # ['L'], ['L','V'], ['L','E','V']    probabilidades: Dict[str, float]  # {'L': 0.45, 'E': 0.30, 'V': 0.25}    clasificacion: str  # 'Ancla', 'Divisor', 'TendenciaX', 'Neutro'    valor_multiple: float = 0.0  # Valor calculado para ser múltiple        @property    def tipo(self) -> str:        """Determinar tipo basado en número de opciones"""        if len(self.opciones) == 1:            return "sencillo"        elif len(self.opciones) == 2:            return "doble"        elif len(self.opciones) == 3:            return "triple"        else:            return "multiple"@dataclassclass QuinielaMultiple:    """Quiniela compacta con múltiples opciones por partido"""    partidos: List[PartidoMultiple]        @property    def combinaciones_totales(self) -> int:        """Calcular número total de combinaciones"""        total = 1        for partido in self.partidos:            total *= len(partido.opciones)        return total        @property    def costo_total(self) -> float:        """Calcular costo total (asumiendo $15 MXN por quiniela)"""        return self.combinaciones_totales * 15.0        @property    def resumen(self) -> Dict:        """Resumen de la configuración"""        sencillos = len([p for p in self.partidos if p.tipo == "sencillo"])        dobles = len([p for p in self.partidos if p.tipo == "doble"])        triples = len([p for p in self.partidos if p.tipo == "triple"])                return {            'sencillos': sencillos,            'dobles': dobles,            'triples': triples,            'combinaciones_totales': self.combinaciones_totales,            'costo_total': self.costo_total        }class ValorMultipleCalculator:    """Calculadora de valor para determinar dónde colocar dobles/triples"""        @staticmethod    def calcular_valor_doble(partido_probs: Dict[str, float], clasificacion: str) -> float:        """        Calcula qué tan valioso es convertir este partido en doble                Args:            partido_probs: {'L': 0.45, 'E': 0.30, 'V': 0.25}            clasificacion: 'Ancla', 'Divisor', 'TendenciaX', 'Neutro'                Returns:            float: Valor entre 0-1 (mayor = más valioso)        """        p_L, p_E, p_V = partido_probs['L'], partido_probs['E'], partido_probs['V']                # Las dos opciones más probables        probabilidades_ordenadas = sorted([p_L, p_E, p_V], reverse=True)        valor_base = probabilidades_ordenadas[0] + probabilidades_ordenadas[1]                # Bonus por clasificación        bonus = 0.0        if clasificacion == "Divisor":  # 0.40 < p_max < 0.60            bonus += 0.15        elif clasificacion == "TendenciaX":            bonus += 0.10        elif clasificacion == "Ancla":  # Muy confiable, menos valioso para doble            bonus -= 0.20                    # Penalty si una opción domina demasiado        if probabilidades_ordenadas[0] > 0.65:            bonus -= 0.15                    return max(0.0, min(1.0, valor_base + bonus))        @staticmethod    def calcular_valor_triple(partido_probs: Dict[str, float], clasificacion: str) -> float:        """        Calcula qué tan valioso es convertir este partido en triple                Args:            partido_probs: {'L': 0.45, 'E': 0.30, 'V': 0.25}            clasificacion: 'Ancla', 'Divisor', 'TendenciaX', 'Neutro'                Returns:            float: Valor entre 0-1 (mayor = más valioso)        """        p_L, p_E, p_V = partido_probs['L'], partido_probs['E'], partido_probs['V']                # Triple es valioso cuando las probabilidades están parejas        varianza = np.var([p_L, p_E, p_V])        valor_base = 1 / (1 + varianza * 10)  # Menor varianza = mayor valor                # Bonus por clasificación        bonus = 0.0        if clasificacion == "Divisor":            bonus += 0.20        elif clasificacion == "TendenciaX" and p_E > 0.25:  # Empate probable            bonus += 0.15        elif clasificacion == "Ancla":  # Muy confiable, malo para triple            bonus -= 0.30                    return max(0.0, min(1.0, valor_base + bonus))class MultipleQuinielasGenerator:    """    Generador inteligente de quinielas múltiples    Integra con la Metodología Definitiva existente    """        def __init__(self):        self.calculator = ValorMultipleCalculator()            def generar_quiniela_multiple(self,                                 matches_data: List[Dict],                                 num_dobles: int = 0,                                 num_triples: int = 0,                                overrides: Optional[Dict[int, List[str]]] = None) -> QuinielaMultiple:        """        Genera una quiniela múltiple inteligente                Args:            matches_data: Lista de diccionarios con datos de partidos                Formato: [{'numero': 1, 'prob_l': 0.45, 'prob_e': 0.30, 'prob_v': 0.25, 'clasificacion': 'Divisor'}, ...]            num_dobles: Número de dobles deseados            num_triples: Número de triples deseados              overrides: Configuración manual por partido {partido_num: ['L', 'V']}                    Returns:            QuinielaMultiple: Quiniela configurada automáticamente        """        logger.info(f"Generando quiniela múltiple: {num_dobles} dobles, {num_triples} triples")                # 1. Convertir datos y calcular valores para múltiples        candidatos_dobles = []        candidatos_triples = []                for match in matches_data:            num_partido = match['numero']            probs = {                'L': match['prob_l'],                'E': match['prob_e'],                 'V': match['prob_v']            }            clasificacion = match['clasificacion']                        # Calcular valores            valor_doble = self.calculator.calcular_valor_doble(probs, clasificacion)            valor_triple = self.calculator.calcular_valor_triple(probs, clasificacion)                        candidatos_dobles.append((num_partido - 1, valor_doble, probs, clasificacion))            candidatos_triples.append((num_partido - 1, valor_triple, probs, clasificacion))                # 2. Seleccionar mejores candidatos        mejores_triples = sorted(candidatos_triples, key=lambda x: x[1], reverse=True)[:num_triples]        mejores_dobles = sorted(candidatos_dobles, key=lambda x: x[1], reverse=True)[:num_dobles]                # Evitar solapamiento (si un partido es triple, no puede ser doble)        partidos_triple = {idx for idx, _, _, _ in mejores_triples}        mejores_dobles = [(idx, val, probs, clas) for idx, val, probs, clas in mejores_dobles                          if idx not in partidos_triple][:num_dobles]                # 3. Construir partidos múltiples        partidos = []                for i, match in enumerate(matches_data):            probs = {                'L': match['prob_l'],                'E': match['prob_e'],                 'V': match['prob_v']            }            clasificacion = match['clasificacion']                        # Verificar override manual            if overrides and i in overrides:                opciones = overrides[i]                valor_multiple = 1.0  # Override tiene prioridad máxima                            # Verificar si debe ser triple            elif i in partidos_triple:                opciones = self._generar_opciones_triple(probs, clasificacion)                valor_multiple = next(val for idx, val, _, _ in mejores_triples if idx == i)                            # Verificar si debe ser doble            elif any(idx == i for idx, _, _, _ in mejores_dobles):                opciones = self._generar_opciones_doble(probs, clasificacion)                valor_multiple = next(val for idx, val, _, _ in mejores_dobles if idx == i)                            # Caso por defecto: sencillo            else:                opciones = [self._obtener_mejor_opcion(probs)]                valor_multiple = 0.0                        partido = PartidoMultiple(                numero=i + 1,                opciones=opciones,                probabilidades=probs,                clasificacion=clasificacion,                valor_multiple=valor_multiple            )            partidos.append(partido)                quiniela = QuinielaMultiple(partidos=partidos)                # 4. Validar y ajustar si es necesario        self._validar_y_ajustar(quiniela)                logger.info(f"Quiniela generada: {quiniela.resumen}")        return quiniela        def _generar_opciones_doble(self, probs: Dict[str, float], clasificacion: str) -> List[str]:        """Generar opciones para un doble inteligentemente"""        p_L, p_E, p_V = probs['L'], probs['E'], probs['V']                # Lógica específica por clasificación        if clasificacion == "TendenciaX" and p_E > 0.25:            # Incluir empate + mejor resultado            mejor_resultado = 'L' if p_L > p_V else 'V'            return ['E', mejor_resultado]                elif abs(p_L - p_V) < 0.08:  # Muy cerrado entre L y V            return ['L', 'V']                else:            # Las dos opciones más probables            opciones_ordenadas = sorted(['L', 'E', 'V'], key=lambda x: probs[x], reverse=True)            return opciones_ordenadas[:2]        def _generar_opciones_triple(self, probs: Dict[str, float], clasificacion: str) -> List[str]:        """Generar opciones para un triple (siempre todas las opciones)"""        return ['L', 'E', 'V']        def _obtener_mejor_opcion(self, probs: Dict[str, float]) -> str:        """Obtener la opción más probable"""        return max(['L', 'E', 'V'], key=lambda x: probs[x])        def _validar_y_ajustar(self, quiniela: QuinielaMultiple):        """Validar y ajustar quiniela según reglas de la metodología"""                # Validar límites de costo (ejemplo: máximo 5000 quinielas)        if quiniela.combinaciones_totales > 5000:            logger.warning(f"Demasiadas combinaciones ({quiniela.combinaciones_totales}), ajustando...")            self._reducir_complejidad(quiniela)                # Validar que tengamos al menos algunos empates probables        empates_incluidos = sum(1 for p in quiniela.partidos if 'E' in p.opciones)        if empates_incluidos < 3:            logger.info("Ajustando para incluir más empates...")            self._incluir_mas_empates(quiniela)        def _reducir_complejidad(self, quiniela: QuinielaMultiple):        """Reducir complejidad convirtiendo algunos triples en dobles"""        # Convertir el triple con menor valor a doble        triples = [(i, p) for i, p in enumerate(quiniela.partidos) if p.tipo == "triple"]        if triples:            idx, partido = min(triples, key=lambda x: x[1].valor_multiple)            new_opciones = self._generar_opciones_doble(partido.probabilidades, partido.clasificacion)            quiniela.partidos[idx].opciones = new_opciones            logger.info(f"Partido {idx+1} convertido de triple a doble")        def _incluir_mas_empates(self, quiniela: QuinielaMultiple):        """Incluir más empates en partidos propensos"""        for partido in quiniela.partidos:            if (partido.tipo == "sencillo" and                 partido.probabilidades['E'] > 0.20 and                 'E' not in partido.opciones):                # Convertir a doble incluyendo empate                mejor_resultado = self._obtener_mejor_opcion(partido.probabilidades)                partido.opciones = ['E', mejor_resultado]                logger.info(f"Partido {partido.numero} ajustado para incluir empate")                break# Funciones de utilidad para integración con la app existentedef calcular_presupuesto(num_dobles: int, num_triples: int, num_partidos: int = 14) -> Dict:    """    Calcular presupuesto aproximado para una configuración de múltiples        Returns:        Dict con combinaciones aproximadas y costo    """    # Estimación conservadora (asume que dobles y triples se colocan estratégicamente)    combinaciones_dobles = 2 ** min(num_dobles, 8)  # Límite realista    combinaciones_triples = 3 ** min(num_triples, 3)  # Límite realista        # Los demás partidos son sencillos    partidos_sencillos = num_partidos - num_dobles - num_triples    combinaciones_sencillos = 1 ** partidos_sencillos        total_combinaciones = combinaciones_dobles * combinaciones_triples * combinaciones_sencillos    costo_total = total_combinaciones * 15.0        return {        'combinaciones_aproximadas': total_combinaciones,        'costo_total': costo_total,        'costo_formateado': f"${costo_total:,.0f}"    }def validar_configuracion(num_dobles: int, num_triples: int) -> Tuple[bool, str]:    """    Validar que la configuración sea razonable        Returns:        (es_valida, mensaje)    """    if num_dobles < 0 or num_triples < 0:        return False, "❌ Número de dobles/triples no puede ser negativo"        if num_dobles + num_triples > 14:        return False, "❌ No puedes tener más múltiples que partidos"        presupuesto = calcular_presupuesto(num_dobles, num_triples)    if presupuesto['combinaciones_aproximadas'] > 10000:        return False, f"⚠️ Demasiadas combinaciones ({presupuesto['combinaciones_aproximadas']:,}). Reduce dobles/triples."        if presupuesto['costo_total'] > 50000:        return False, f"💰 Costo muy alto ({presupuesto['costo_formateado']}). Considera reducir."        return True, "✅ Configuración válida"# Funciones de integración con datos existentesdef convertir_matches_data(df_prob, df_classification=None):    """    Convertir datos existentes al formato requerido por MultipleQuinielasGenerator        Args:        df_prob: DataFrame con probabilidades (formato actual de la app)        df_classification: DataFrame con clasificaciones (opcional)        Returns:        List[Dict]: Datos formateados para el generador    """    # DEBUG: Mostrar qué columnas están disponibles    print("=== DEBUG: Columnas disponibles en df_prob ===")    print("Columnas:", list(df_prob.columns))    print("Primera fila:", df_prob.iloc[0].to_dict() if len(df_prob) > 0 else "Sin datos")        matches_data = []        for i, row in df_prob.iterrows():        # Buscar probabilidades con múltiples variantes de nombres        columnas_l = ['prob_l', 'P_L', 'p_final_L', 'p_blend_L']        columnas_e = ['prob_e', 'P_E', 'p_final_E', 'p_blend_E']        columnas_v = ['prob_v', 'P_V', 'p_final_V', 'p_blend_V']                # Encontrar la primera columna que existe        prob_l = None        for col in columnas_l:            if col in row and not pd.isna(row[col]):                prob_l = row[col]                if i == 0:  # Solo log para el primer partido                    print(f"DEBUG: Usando columna '{col}' para prob_L = {prob_l}")                break                prob_e = None        for col in columnas_e:            if col in row and not pd.isna(row[col]):                prob_e = row[col]                if i == 0:                    print(f"DEBUG: Usando columna '{col}' para prob_E = {prob_e}")                break                        prob_v = None        for col in columnas_v:            if col in row and not pd.isna(row[col]):                prob_v = row[col]                if i == 0:                    print(f"DEBUG: Usando columna '{col}' para prob_V = {prob_v}")                break                # Fallback a 0.33 si no se encontró nada        prob_l = prob_l if prob_l is not None else 0.33        prob_e = prob_e if prob_e is not None else 0.33        prob_v = prob_v if prob_v is not None else 0.33                if i == 0:            print(f"DEBUG: Probabilidades finales para partido 1: L={prob_l}, E={prob_e}, V={prob_v}")                match_data = {            'numero': i + 1,            'prob_l': float(prob_l),            'prob_e': float(prob_e),            'prob_v': float(prob_v),            'clasificacion': 'Neutro'  # Default        }                # Agregar clasificación si está disponible        if df_classification is not None and i < len(df_classification):            match_data['clasificacion'] = df_classification.iloc[i].get('clasificacion', 'Neutro')        else:            # Clasificar basado en probabilidades            p_max = max(prob_l, prob_e, prob_v)            if p_max > 0.60:                match_data['clasificacion'] = 'Ancla'            elif 0.40 < p_max < 0.60:                match_data['clasificacion'] = 'Divisor'            elif prob_e > 0.30:                match_data['clasificacion'] = 'TendenciaX'                matches_data.append(match_data)        print(f"=== DEBUG: Convertidos {len(matches_data)} partidos ===")    return matches_data