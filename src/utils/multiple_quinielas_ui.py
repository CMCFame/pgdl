#!/usr/bin/env python3"""Componente UI para Quinielas M√∫ltiplesIntegraci√≥n con Streamlit Dashboard existenteEste archivo se importa en dashboard.py sin modificar funcionalidad actual"""import streamlit as stimport pandas as pdimport plotly.express as pximport plotly.graph_objects as gofrom plotly.subplots import make_subplotsimport loggingfrom pathlib import Pathimport jsonfrom datetime import datetime
import numpy as np# Import del nuevo m√≥dulotry:    from src.utils.multiple_quinielas_generator import (        MultipleQuinielasGenerator,         calcular_presupuesto,         validar_configuracion,        convertir_matches_data    )except ImportError:    st.error("‚ö†Ô∏è M√≥dulo de quinielas m√∫ltiples no disponible. Verifica la instalaci√≥n.")    MultipleQuinielasGenerator = Nonelogger = logging.getLogger(__name__)def multiple_quinielas_section():    """    Secci√≥n principal para configurar y generar quinielas m√∫ltiples    NUEVA funcionalidad que se integra con el sidebar existente    """    st.title("üéØ Quinielas M√∫ltiples Inteligentes")    st.markdown("Dise√±o automatizado con dobles y triples estrat√©gicos")        # Verificar disponibilidad del m√≥dulo    if MultipleQuinielasGenerator is None:        st.error("üö´ Funcionalidad no disponible")        return        # Verificar datos necesarios    if not _verificar_datos_disponibles():        _mostrar_requisitos_datos()        return        # Layout principal    col1, col2 = st.columns([1, 2])        with col1:        st.subheader("‚öôÔ∏è Configuraci√≥n")        configuracion = _configuracion_ui()                if configuracion['valida']:            presupuesto = calcular_presupuesto(                configuracion['dobles'],                 configuracion['triples']            )            _mostrar_presupuesto(presupuesto)                        # Bot√≥n de generaci√≥n            if st.button("üéØ Dise√±ar Quiniela", type="primary", use_container_width=True):                with st.spinner("ü§ñ La IA est√° dise√±ando tu quiniela..."):                    resultado = _generar_quiniela_multiple(configuracion)                    if resultado:                        st.session_state.quiniela_multiple = resultado                        st.success("‚úÖ Quiniela dise√±ada exitosamente!")                        st.rerun()        with col2:        st.subheader("üìã Resultado")                if hasattr(st.session_state, 'quiniela_multiple') and st.session_state.quiniela_multiple:            _mostrar_quiniela_generada(st.session_state.quiniela_multiple)        else:            _mostrar_placeholder_quiniela()def _verificar_datos_disponibles() -> bool:    """Verificar que tengamos los datos necesarios"""    # Verificar session state o archivos    if hasattr(st.session_state, 'current_jornada') and st.session_state.current_jornada:        return True        # Verificar archivos de probabilidades    data_dir = Path("data/processed")    if data_dir.exists():        prob_files = list(data_dir.glob("prob_*.csv"))        return len(prob_files) > 0        return Falsedef _mostrar_requisitos_datos():    """Mostrar qu√© datos se necesitan"""    st.info("""    üìä **Datos Requeridos**        Para usar quinielas m√∫ltiples necesitas:    1. Ejecutar el **Pipeline Completo** primero    2. O cargar archivos con probabilidades calibradas        Ve a la secci√≥n **üöÄ Pipeline Completo** para generar los datos necesarios.    """)def _configuracion_ui() -> dict:    """Interface de configuraci√≥n de usuario"""        # Configuraci√≥n b√°sica    st.markdown("#### üé≤ Estrategia de M√∫ltiples")        # ‚úÖ CORRECCI√ìN AQU√ç: Cambiar value= por index=    num_dobles = st.selectbox(        "Dobles deseados:",        options=[0, 1, 2, 3, 4, 5, 6, 7, 8],        index=2,  # ‚Üê CAMBIADO: era value=2, ahora index=2        help="Partidos con 2 opciones (ej: L, V)"    )        # ‚úÖ CORRECCI√ìN AQU√ç: Cambiar value= por index=    num_triples = st.selectbox(        "Triples deseados:",        options=[0, 1, 2, 3, 4],        index=1,  # ‚Üê CAMBIADO: era value=1, ahora index=1        help="Partidos con 3 opciones (L, E, V)"    )        # Validaci√≥n en tiempo real    es_valida, mensaje = validar_configuracion(num_dobles, num_triples)        if not es_valida:        st.error(mensaje)    else:        st.success(mensaje)        # Configuraci√≥n avanzada (opcional)    with st.expander("‚öôÔ∏è Configuraci√≥n Avanzada"):        st.markdown("**üéØ Estrategia de Colocaci√≥n**")                estrategia_dobles = st.radio(            "Prioridad para dobles:",            ["Autom√°tica (IA decide)", "Favor partidos cerrados", "Favor partidos con empate"],            help="C√≥mo la IA decide d√≥nde colocar los dobles"        )                estrategia_triples = st.radio(            "Prioridad para triples:",            ["Autom√°tica (IA decide)", "Partidos m√°s inciertos", "Incluir empates probables"],            help="C√≥mo la IA decide d√≥nde colocar los triples"        )                # Override manual (avanzado)        usar_overrides = st.checkbox("üîß Configuraci√≥n manual de partidos")        overrides = {}                if usar_overrides:            st.markdown("**‚ö†Ô∏è Solo para usuarios avanzados**")            for i in range(1, 8):  # Primeros 7 partidos como ejemplo                opciones_partido = st.multiselect(                    f"Partido {i}:",                    options=['L', 'E', 'V'],                    default=[],                    key=f"partido_{i}_manual"                )                if opciones_partido:                    overrides[i-1] = opciones_partido        return {        'dobles': num_dobles,        'triples': num_triples,        'valida': es_valida,        'mensaje': mensaje,        'estrategia_dobles': estrategia_dobles,        'estrategia_triples': estrategia_triples,        'overrides': overrides if usar_overrides else None    }def _mostrar_presupuesto(presupuesto: dict):    """Mostrar informaci√≥n de presupuesto"""    st.markdown("#### üí∞ Presupuesto Calculado")        # M√©tricas principales    col1, col2 = st.columns(2)        with col1:        st.metric(            "Combinaciones",            f"{presupuesto['combinaciones_aproximadas']:,}",            help="N√∫mero total de quinielas generadas"        )        with col2:        st.metric(            "Costo Total",            presupuesto['costo_formateado'],            help="Costo en pesos mexicanos ($15 por quiniela)"        )        # Indicador visual del costo    if presupuesto['costo_total'] <= 1000:        color = "green"        nivel = "Econ√≥mico üíö"    elif presupuesto['costo_total'] <= 5000:        color = "orange"         nivel = "Moderado üß°"    else:        color = "red"        nivel = "Alto üî¥"        st.markdown(f"**Nivel de inversi√≥n:** {nivel}")        # Progreso bar visual    max_budget = 10000  # L√≠mite visual    progress = min(presupuesto['costo_total'] / max_budget, 1.0)    st.progress(progress)def _generar_quiniela_multiple(configuracion: dict):    """Generar quiniela m√∫ltiple usando la IA"""    try:        # 1. Cargar datos de probabilidades        matches_data = _cargar_matches_data()        if not matches_data:            st.error("‚ùå No se pudieron cargar las probabilidades")            return None                # 2. Inicializar generador        generator = MultipleQuinielasGenerator()                # 3. Generar quiniela        quiniela = generator.generar_quiniela_multiple(            matches_data=matches_data,            num_dobles=configuracion['dobles'],            num_triples=configuracion['triples'],            overrides=configuracion.get('overrides')        )                # 4. Agregar informaci√≥n adicional        resultado = {            'quiniela': quiniela,            'configuracion': configuracion,            'timestamp': datetime.now(),            'matches_data': matches_data        }                # 5. Guardar para export posterior        _guardar_resultado(resultado)                return resultado            except Exception as e:        logger.error(f"Error generando quiniela m√∫ltiple: {e}")        st.error(f"‚ùå Error: {e}")        return Nonedef _cargar_matches_data():    """Cargar datos de partidos desde archivos existentes"""    try:        # Intentar cargar desde session state primero        if hasattr(st.session_state, 'current_jornada'):            jornada = st.session_state.current_jornada            prob_file = f"data/processed/prob_draw_adjusted_{jornada}.csv"                        if Path(prob_file).exists():                df_prob = pd.read_csv(prob_file)                return convertir_matches_data(df_prob)                # Fallback: buscar el archivo m√°s reciente        data_dir = Path("data/processed")        prob_files = list(data_dir.glob("prob_*.csv"))                if prob_files:            latest_file = max(prob_files, key=lambda p: p.stat().st_mtime)            df_prob = pd.read_csv(latest_file)            return convertir_matches_data(df_prob)                return None            except Exception as e:        logger.error(f"Error cargando matches data: {e}")        return Nonedef _mostrar_quiniela_generada(resultado: dict):    """Mostrar la quiniela generada de forma visual"""    quiniela = resultado['quiniela']        # Resumen ejecutivo    resumen = quiniela.resumen        col1, col2, col3 = st.columns(3)    with col1:        st.metric("Sencillos", resumen['sencillos'])    with col2:        st.metric("Dobles", resumen['dobles'])     with col3:        st.metric("Triples", resumen['triples'])        st.markdown("---")        # Quiniela visual    st.markdown("#### üìã Quiniela Dise√±ada")        # Crear tabla visual    quiniela_data = []    for partido in quiniela.partidos:        opciones_str = " ".join(partido.opciones)                # Color coding por tipo        if partido.tipo == "sencillo":            tipo_emoji = "‚ö™"        elif partido.tipo == "doble":            tipo_emoji = "üü°"        else:  # triple            tipo_emoji = "üî¥"                quiniela_data.append({            "Partido": f"{tipo_emoji} {partido.numero:02d}",            "Pron√≥stico": opciones_str,            "Tipo": partido.tipo.title(),            "Probabilidades": f"L:{partido.probabilidades['L']:.2f} E:{partido.probabilidades['E']:.2f} V:{partido.probabilidades['V']:.2f}"        })        df_display = pd.DataFrame(quiniela_data)    st.dataframe(df_display, use_container_width=True, hide_index=True)        # Informaci√≥n adicional    st.markdown("#### üìä An√°lisis de la Quiniela")        col1, col2 = st.columns(2)        with col1:        st.info(f"""        **üéØ Estrategia Aplicada**        - Total de combinaciones: **{resumen['combinaciones_totales']:,}**        - Costo total: **${resumen['costo_total']:,.0f}**        - Promedio por quiniela: **$15**        """)        with col2:        # Gr√°fico de distribuci√≥n        tipos = ['Sencillos', 'Dobles', 'Triples']        valores = [resumen['sencillos'], resumen['dobles'], resumen['triples']]        colores = ['#e8f4fd', '#ffd700', '#ff6b6b']                fig = px.pie(            values=valores,             names=tipos,            title="Distribuci√≥n de Tipos",            color_discrete_sequence=colores        )        fig.update_layout(height=300)        st.plotly_chart(fig, use_container_width=True)        # Botones de acci√≥n    st.markdown("---")    col1, col2, col3 = st.columns(3)        with col1:        if st.button("üìÑ Exportar PDF", use_container_width=True):            _exportar_pdf(resultado)    with col2:        if st.button("üìä Ver An√°lisis Detallado", use_container_width=True):            _mostrar_analisis_detallado(resultado)    with col3:        if st.button("üîÑ Generar Nueva", use_container_width=True):            if 'quiniela_multiple' in st.session_state:                del st.session_state.quiniela_multiple            st.rerun()def _mostrar_placeholder_quiniela():    """Mostrar placeholder cuando no hay quiniela generada"""    st.info("""    üëà **Configura tu estrategia**        1. Selecciona cu√°ntos **dobles** y **triples** quieres    2. Revisa el **presupuesto** calculado    3. Haz clic en **"Dise√±ar Quiniela"**        La IA utilizar√° la Metodolog√≠a Definitiva para colocar     estrat√©gicamente tus m√∫ltiples en los partidos m√°s prometedores.    """)        # Ejemplo visual    st.markdown("#### üìã Ejemplo de Resultado")        ejemplo_data = [        {"Partido": "‚ö™ 01", "Pron√≥stico": "L", "Tipo": "Sencillo"},        {"Partido": "üü° 02", "Pron√≥stico": "L V", "Tipo": "Doble"},        {"Partido": "‚ö™ 03", "Pron√≥stico": "V", "Tipo": "Sencillo"},        {"Partido": "üî¥ 04", "Pron√≥stico": "L E V", "Tipo": "Triple"},        {"Partido": "‚ö™ ...", "Pron√≥stico": "...", "Tipo": "..."},    ]        df_ejemplo = pd.DataFrame(ejemplo_data)    st.dataframe(df_ejemplo, use_container_width=True, hide_index=True)def _guardar_resultado(resultado: dict):    """Guardar resultado para an√°lisis posterior"""    try:        output_dir = Path("data/outputs")        output_dir.mkdir(exist_ok=True)                timestamp = resultado['timestamp'].strftime("%Y%m%d_%H%M%S")        filename = f"quiniela_multiple_{timestamp}.json"                # Serializar resultado (excluyendo objetos no serializables)        data_to_save = {            'timestamp': resultado['timestamp'].isoformat(),            'configuracion': resultado['configuracion'],            'resumen': resultado['quiniela'].resumen,            'partidos': [                {                    'numero': p.numero,                    'opciones': p.opciones,                    'tipo': p.tipo,                    'clasificacion': p.clasificacion,                    'probabilidades': p.probabilidades                }                for p in resultado['quiniela'].partidos            ]        }                with open(output_dir / filename, 'w', encoding='utf-8') as f:            json.dump(data_to_save, f, indent=2, ensure_ascii=False)                    logger.info(f"Resultado guardado: {filename}")            except Exception as e:        logger.error(f"Error guardando resultado: {e}")def _exportar_pdf(resultado: dict):    """Exportar quiniela a PDF"""    st.info("üöß Funci√≥n de exportaci√≥n PDF en desarrollo")    st.markdown("Por ahora puedes usar la funci√≥n de impresi√≥n del navegador")def _mostrar_analisis_detallado(resultado: dict):    """Mostrar an√°lisis detallado en modal/expander"""    with st.expander("üìä An√°lisis Detallado", expanded=True):        quiniela = resultado['quiniela']                st.markdown("#### üéØ Justificaci√≥n de Decisiones")                for partido in quiniela.partidos:            if partido.tipo != "sencillo":                justificacion = _generar_justificacion(partido)                st.markdown(f"""                **Partido {partido.numero}** ({partido.tipo.title()})                - **Opciones:** {' - '.join(partido.opciones)}                - **Clasificaci√≥n:** {partido.clasificacion}                - **Justificaci√≥n:** {justificacion}                """)def _generar_justificacion(partido) -> str:    """Generar explicaci√≥n de por qu√© se eligi√≥ esta configuraci√≥n"""    p_L, p_E, p_V = partido.probabilidades['L'], partido.probabilidades['E'], partido.probabilidades['V']        if partido.tipo == "doble":        if 'E' in partido.opciones:            return f"Incluye empate (prob: {p_E:.1%}) + mejor resultado"        else:            return f"Partidos cerrados entre opciones principales"        elif partido.tipo == "triple":        varianza = np.var([p_L, p_E, p_V])        return f"Resultado muy incierto (varianza: {varianza:.3f}), todas las opciones viables"        return "Resultado m√°s probable seleccionado"# Funci√≥n principal de integraci√≥ndef add_multiple_quinielas_to_sidebar():    """    Funci√≥n para agregar la opci√≥n al sidebar existente    LLAMAR desde dashboard.py    """    return "üéØ Quinielas M√∫ltiples"