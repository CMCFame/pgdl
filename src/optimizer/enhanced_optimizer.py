#!/usr/bin/env python3"""Optimizador mejorado para Progol Engine v2Soporte para 21 partidos (14 regulares + 7 revancha)Generación de portafolio Core + Satélites optimizado"""import pandas as pdimport numpy as npimport jsonimport loggingfrom pathlib import Pathimport timefrom typing import Dict, List, Tuple, Optional, Unionfrom dataclasses import dataclassfrom datetime import datetimeimport itertoolsimport random# Configuración de logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)@dataclassclass MatchInfo:    """Información de un partido"""    match_id: str    partido: int    tipo: str  # 'Regular' o 'Revancha'    prob_l: float    prob_e: float    prob_v: float    favorito: str    clasificacion: str  # 'Ancla', 'Divisor', 'Tendencia_X', 'Neutro'    confianza: float@dataclassclass QuinielaInfo:    """Información de una quiniela"""    quiniela_id: str    tipo: str  # 'Core' o 'Satélite'    signos: List[str]    source: str    pr_11: float = 0.0    mu: float = 0.0    sigma: float = 0.0    l_count: int = 0    e_count: int = 0    v_count: int = 0class MatchClassifier:    """Clasificador de partidos mejorado"""        def __init__(self, config: Dict = None):        self.config = config or {            'ancla_threshold': 0.60,            'divisor_min': 0.40,            'divisor_max': 0.60,            'empate_threshold': 0.30,            'volatility_threshold': 0.15        }        def classify_match(self, match: MatchInfo) -> str:        """Clasificar un partido según sus probabilidades"""        max_prob = max(match.prob_l, match.prob_e, match.prob_v)                # Ancla: alta confianza (>60%)        if max_prob > self.config['ancla_threshold']:            return 'Ancla'                # Tendencia X: empate con probabilidad alta        if match.prob_e > self.config['empate_threshold'] and match.prob_e == max_prob:            return 'Tendencia_X'                # Divisor: probabilidades intermedias        if self.config['divisor_min'] < max_prob <= self.config['divisor_max']:            return 'Divisor'                # Neutro: todo lo demás        return 'Neutro'        def classify_all_matches(self, matches: List[MatchInfo]) -> Dict[str, List[int]]:        """Clasificar todos los partidos"""        classification = {            'Ancla': [],            'Divisor': [],            'Tendencia_X': [],            'Neutro': []        }                for match in matches:            class_type = self.classify_match(match)            match.clasificacion = class_type            classification[class_type].append(match.partido - 1)  # Index 0-based                logger.info(f"Clasificación: {dict((k, len(v)) for k, v in classification.items())}")        return classificationclass EnhancedPortfolioGenerator:    """Generador de portafolio mejorado para 21 partidos"""        def __init__(self, n_partidos: int = 21, n_quinielas: int = 30):        self.n_partidos = n_partidos        self.n_quinielas = n_quinielas        self.n_cores = 4        self.n_satelites = n_quinielas - self.n_cores                # Límites de distribución        self.dist_limits = {            'L': (0.35, 0.41),  # 35-41% locales            'E': (0.25, 0.33),  # 25-33% empates            'V': (0.30, 0.36)   # 30-36% visitantes        }                # Configuración de empates        self.empates_min = max(4, int(0.20 * n_partidos))  # Mín 20% empates        self.empates_max = min(8, int(0.35 * n_partidos))  # Máx 35% empates                logger.info(f"Configuración: {n_partidos} partidos, {n_quinielas} quinielas")        logger.info(f"Empates por boleto: {self.empates_min}-{self.empates_max}")        def generate_core_quinielas(self, matches: List[MatchInfo],                                classification: Dict[str, List[int]]) -> List[QuinielaInfo]:        """Generar quinielas Core"""        logger.info("Generando quinielas Core...")                cores = []        anclas = classification['Ancla']                for i in range(self.n_cores):            signos = ['L'] * self.n_partidos  # Inicializar                        # Fijar anclas con su resultado favorito            for match_idx in anclas:                match = matches[match_idx]                if match.prob_l >= max(match.prob_e, match.prob_v):                    signos[match_idx] = 'L'                elif match.prob_e >= max(match.prob_l, match.prob_v):                    signos[match_idx] = 'E'                else:                    signos[match_idx] = 'V'                        # Añadir empates obligatorios            empates_needed = self.empates_min            empates_current = signos.count('E')                        if empates_current < empates_needed:                # Convertir algunos partidos neutros a empates                neutros = [i for i in classification['Neutro'] if signos[i] != 'E']                tendencias_x = classification['Tendencia_X']                                candidates = tendencias_x + neutros                random.shuffle(candidates)                                for idx in candidates[:empates_needed - empates_current]:                    signos[idx] = 'E'                        # Ajustar distribución general            signos = self._adjust_distribution(signos, matches, i)                        # Crear quiniela Core            core = QuinielaInfo(                quiniela_id=f'C{i+1:02d}',                tipo='Core',                signos=signos,                source=f'core_strategy_{i+1}'            )                        # Calcular métricas            self._calculate_quiniela_metrics(core, matches)            cores.append(core)                logger.info(f"✅ {len(cores)} quinielas Core generadas")        return cores        def generate_satellite_quinielas(self, cores: List[QuinielaInfo],                                    matches: List[MatchInfo],                                   classification: Dict[str, List[int]]) -> List[QuinielaInfo]:        """Generar quinielas Satélite"""        logger.info("Generando quinielas Satélite...")                satelites = []        divisores = classification['Divisor']                # Generar pares de satélites anticorrelacionados        n_pares = self.n_satelites // 2                for pair_idx in range(n_pares):            # Satélite A y B del par            for variant in ['A', 'B']:                signos = cores[pair_idx % len(cores)].signos.copy()                                # Invertir divisores para crear anticorrelación                for div_idx in divisores:                    current_sign = signos[div_idx]                    match = matches[div_idx]                                        if variant == 'A':                        # Estrategia A: cambiar según segunda opción más probable                        probs = {'L': match.prob_l, 'E': match.prob_e, 'V': match.prob_v}                        sorted_probs = sorted(probs.items(), key=lambda x: x[1], reverse=True)                        signos[div_idx] = sorted_probs[1][0]  # Segunda opción                    else:                        # Estrategia B: cambiar según tercera opción más probable                        probs = {'L': match.prob_l, 'E': match.prob_e, 'V': match.prob_v}                        sorted_probs = sorted(probs.items(), key=lambda x: x[1], reverse=True)                        signos[div_idx] = sorted_probs[2][0]  # Tercera opción                                # Ajustar empates                signos = self._ensure_empates_range(signos)                                # Ajustar distribución                signos = self._adjust_distribution(signos, matches, pair_idx)                                # Crear satélite                satelite = QuinielaInfo(                    quiniela_id=f'S{len(satelites)+1:02d}',                    tipo='Satélite',                    signos=signos,                    source=f'satellite_pair_{pair_idx+1}_{variant}'                )                                self._calculate_quiniela_metrics(satelite, matches)                satelites.append(satelite)                # Satélites adicionales si es necesario        while len(satelites) < self.n_satelites:            # Generar satélite adicional variando un Core            base_core = cores[len(satelites) % len(cores)]            signos = self._create_variation(base_core.signos, matches, classification)                        satelite = QuinielaInfo(                quiniela_id=f'S{len(satelites)+1:02d}',                tipo='Satélite',                signos=signos,                source=f'satellite_additional_{len(satelites)+1}'            )                        self._calculate_quiniela_metrics(satelite, matches)            satelites.append(satelite)                logger.info(f"✅ {len(satelites)} quinielas Satélite generadas")        return satelites        def _adjust_distribution(self, signos: List[str], matches: List[MatchInfo],                            strategy: int) -> List[str]:        """Ajustar distribución de signos según límites históricos"""        signos = signos.copy()                # Contar signos actuales        counts = {sign: signos.count(sign) for sign in ['L', 'E', 'V']}        total = len(signos)                # Verificar límites        for sign, (min_pct, max_pct) in self.dist_limits.items():            current_pct = counts[sign] / total            min_count = int(min_pct * total)            max_count = int(max_pct * total)                        if counts[sign] < min_count:                # Necesitamos más de este signo                needed = min_count - counts[sign]                candidates = [i for i, s in enumerate(signos) if s != sign]                                # Cambiar los menos probables                for i in range(min(needed, len(candidates))):                    idx = candidates[i]                    signos[idx] = sign                                elif counts[sign] > max_count:                # Tenemos demasiados de este signo                excess = counts[sign] - max_count                candidates = [i for i, s in enumerate(signos) if s == sign]                                # Cambiar los menos probables de este signo                for i in range(min(excess, len(candidates))):                    idx = candidates[i]                    # Cambiar al signo más probable que no sea el actual                    match = matches[idx]                    probs = {'L': match.prob_l, 'E': match.prob_e, 'V': match.prob_v}                    del probs[sign]                    best_alternative = max(probs.items(), key=lambda x: x[1])[0]                    signos[idx] = best_alternative                return signos        def _ensure_empates_range(self, signos: List[str]) -> List[str]:        """Asegurar que los empates estén en el rango correcto"""        signos = signos.copy()        empates_current = signos.count('E')                if empates_current < self.empates_min:            # Necesitamos más empates            needed = self.empates_min - empates_current            non_empates = [i for i, s in enumerate(signos) if s != 'E']                        for i in range(min(needed, len(non_empates))):                signos[non_empates[i]] = 'E'                        elif empates_current > self.empates_max:            # Tenemos demasiados empates            excess = empates_current - self.empates_max            empates_indices = [i for i, s in enumerate(signos) if s == 'E']                        for i in range(min(excess, len(empates_indices))):                idx = empates_indices[i]                # Cambiar a L o V según probabilidades                if random.random() < 0.5:                    signos[idx] = 'L'                else:                    signos[idx] = 'V'                return signos        def _create_variation(self, base_signos: List[str], matches: List[MatchInfo],                          classification: Dict[str, List[int]]) -> List[str]:        """Crear variación de una quiniela base"""        signos = base_signos.copy()                # Cambiar algunos divisores y neutros        changeable = classification['Divisor'] + classification['Neutro']        n_changes = min(3, len(changeable))  # Cambiar máximo 3 partidos                to_change = random.sample(changeable, n_changes)                for idx in to_change:            current = signos[idx]            options = ['L', 'E', 'V']            options.remove(current)            signos[idx] = random.choice(options)                # Ajustar empates y distribución        signos = self._ensure_empates_range(signos)        signos = self._adjust_distribution(signos, matches, 0)                return signos        def _calculate_quiniela_metrics(self, quiniela: QuinielaInfo, matches: List[MatchInfo]):        """Calcular métricas de una quiniela"""        # Contar signos        quiniela.l_count = quiniela.signos.count('L')        quiniela.e_count = quiniela.signos.count('E')        quiniela.v_count = quiniela.signos.count('V')                # Calcular Pr[≥11] aproximada        prob_aciertos = []        for i, signo in enumerate(quiniela.signos):            match = matches[i]            if signo == 'L':                prob_aciertos.append(match.prob_l)            elif signo == 'E':                prob_aciertos.append(match.prob_e)            else:  # 'V'                prob_aciertos.append(match.prob_v)                # Simulación Monte Carlo rápida para Pr[≥11]        n_sim = 1000        aciertos_sim = []                for _ in range(n_sim):            aciertos = sum(1 for p in prob_aciertos if random.random() < p)            aciertos_sim.append(aciertos)                quiniela.mu = np.mean(aciertos_sim)        quiniela.sigma = np.std(aciertos_sim)        quiniela.pr_11 = sum(1 for a in aciertos_sim if a >= 11) / n_simclass GRASPOptimizer:    """Optimizador GRASP mejorado para portafolios"""        def __init__(self, config: Dict = None):        self.config = config or {            'max_iterations': 100,            'alpha': 0.3,            'time_limit': 300,            'improvement_threshold': 0.001        }        def optimize_portfolio(self, quinielas: List[QuinielaInfo],                           matches: List[MatchInfo]) -> List[QuinielaInfo]:        """Optimizar portafolio usando GRASP"""        logger.info("Iniciando optimización GRASP...")                start_time = time.time()        best_portfolio = quinielas.copy()        best_objective = self._calculate_portfolio_objective(best_portfolio)                logger.info(f"Objetivo inicial: {best_objective:.6f}")                iterations = 0        improvements = 0                while (iterations < self.config['max_iterations'] and                time.time() - start_time < self.config['time_limit']):                        # Fase de construcción            candidate_portfolio = self._grasp_construction(quinielas, matches)                        # Fase de mejora local            improved_portfolio = self._local_search(candidate_portfolio, matches)                        # Evaluar objetivo            objective = self._calculate_portfolio_objective(improved_portfolio)                        # Actualizar mejor solución            if objective > best_objective + self.config['improvement_threshold']:                best_portfolio = improved_portfolio                best_objective = objective                improvements += 1                logger.info(f"Iteración {iterations}: Nueva mejor solución {best_objective:.6f}")                        iterations += 1                elapsed_time = time.time() - start_time        logger.info(f"Optimización completada: {iterations} iteraciones, "                   f"{improvements} mejoras, {elapsed_time:.1f}s")                return best_portfolio        def _calculate_portfolio_objective(self, portfolio: List[QuinielaInfo]) -> float:        """Calcular objetivo del portafolio (1 - Π(1 - Pr[≥11]))"""        prob_no_premio = 1.0        for quiniela in portfolio:            prob_no_premio *= (1 - quiniela.pr_11)                return 1 - prob_no_premio        def _grasp_construction(self, base_portfolio: List[QuinielaInfo],                            matches: List[MatchInfo]) -> List[QuinielaInfo]:        """Construcción golosa con elemento aleatorio"""        portfolio = []                for quiniela in base_portfolio:            # Crear variación con probabilidad alpha            if random.random() < self.config['alpha']:                new_quiniela = self._create_random_variation(quiniela, matches)            else:                new_quiniela = quiniela                        portfolio.append(new_quiniela)                return portfolio        def _local_search(self, portfolio: List[QuinielaInfo],                      matches: List[MatchInfo]) -> List[QuinielaInfo]:        """Búsqueda local para mejorar portafolio"""        improved = portfolio.copy()        current_objective = self._calculate_portfolio_objective(improved)                # Intentar swaps en cada quiniela        for i, quiniela in enumerate(improved):            for j in range(len(quiniela.signos)):                # Probar cambiar el signo del partido j                original_sign = quiniela.signos[j]                                for new_sign in ['L', 'E', 'V']:                    if new_sign != original_sign:                        # Hacer el cambio                        quiniela.signos[j] = new_sign                        self._calculate_quiniela_metrics(quiniela, matches)                                                # Evaluar nuevo objetivo                        new_objective = self._calculate_portfolio_objective(improved)                                                if new_objective > current_objective:                            # Mantener el cambio                            current_objective = new_objective                        else:                            # Revertir el cambio                            quiniela.signos[j] = original_sign                            self._calculate_quiniela_metrics(quiniela, matches)                return improved        def _create_random_variation(self, base_quiniela: QuinielaInfo,                                 matches: List[MatchInfo]) -> QuinielaInfo:        """Crear variación aleatoria de una quiniela"""        new_signos = base_quiniela.signos.copy()                # Cambiar 1-3 partidos aleatoriamente        n_changes = random.randint(1, 3)        positions = random.sample(range(len(new_signos)), n_changes)                for pos in positions:            current = new_signos[pos]            options = ['L', 'E', 'V']            options.remove(current)            new_signos[pos] = random.choice(options)                # Crear nueva quiniela        new_quiniela = QuinielaInfo(            quiniela_id=base_quiniela.quiniela_id,            tipo=base_quiniela.tipo,            signos=new_signos,            source=f"{base_quiniela.source}_variation"        )                self._calculate_quiniela_metrics(new_quiniela, matches)        return new_quiniela        def _calculate_quiniela_metrics(self, quiniela: QuinielaInfo, matches: List[MatchInfo]):        """Calcular métricas (reutilizar método del generador)"""        generator = EnhancedPortfolioGenerator()        generator._calculate_quiniela_metrics(quiniela, matches)def load_probabilities_data(jornada: Union[str, int], n_partidos: int = 21) -> List[MatchInfo]:    """Cargar datos de probabilidades"""    try:        # Intentar cargar archivo real        prob_file = f"data/processed/prob_final_{jornada}.csv"                if Path(prob_file).exists():            df = pd.read_csv(prob_file)            logger.info(f"Cargando probabilidades desde {prob_file}")        else:            # Generar datos de ejemplo            logger.warning(f"Archivo {prob_file} no encontrado, generando datos de ejemplo")            df = generate_sample_probabilities(jornada, n_partidos)                # Convertir a MatchInfo        matches = []        for _, row in df.iterrows():            match = MatchInfo(                match_id=row.get('match_id', f'{jornada}-{row["partido"]}'),                partido=row['partido'],                tipo=row.get('tipo', 'Regular' if row['partido'] <= 14 else 'Revancha'),                prob_l=row['p_final_L'],                prob_e=row['p_final_E'],                prob_v=row['p_final_V'],                favorito=row.get('favorito', 'L'),                clasificacion='',                confianza=max(row['p_final_L'], row['p_final_E'], row['p_final_V'])            )            matches.append(match)                logger.info(f"✅ {len(matches)} partidos cargados")        return matches            except Exception as e:        logger.error(f"Error cargando probabilidades: {e}")        return generate_sample_probabilities(jornada, n_partidos)def generate_sample_probabilities(jornada: Union[str, int], n_partidos: int) -> pd.DataFrame:    """Generar probabilidades de ejemplo"""    logger.info(f"Generando {n_partidos} probabilidades de ejemplo")        data = []    for i in range(n_partidos):        # Probabilidades realistas para fútbol        p_l = np.random.uniform(0.25, 0.55)        p_e = np.random.uniform(0.20, 0.35)        p_v = 1.0 - p_l - p_e                # Normalizar        total = p_l + p_e + p_v        p_l /= total        p_e /= total          p_v /= total                favorito = 'L' if p_l >= max(p_e, p_v) else ('E' if p_e >= p_v else 'V')                data.append({            'match_id': f'{jornada}-{i+1}',            'partido': i + 1,            'tipo': 'Regular' if i < 14 else 'Revancha',            'p_final_L': p_l,            'p_final_E': p_e,            'p_final_V': p_v,            'favorito': favorito        })        return pd.DataFrame(data)def export_portfolio_results(portfolio: List[QuinielaInfo], jornada: Union[str, int],                            output_dir: str = "data/processed") -> Dict[str, str]:    """Exportar resultados del portafolio"""    output_paths = {}        # Crear directorio si no existe    Path(output_dir).mkdir(parents=True, exist_ok=True)        # 1. Portafolio principal (CSV)    portfolio_data = []    for quiniela in portfolio:        record = {            'quiniela_id': quiniela.quiniela_id,            'tipo': quiniela.tipo,            'source': quiniela.source,            **{f'P{i+1}': quiniela.signos[i] for i in range(len(quiniela.signos))},            'l_count': quiniela.l_count,            'e_count': quiniela.e_count,            'v_count': quiniela.v_count,            'pr_11': quiniela.pr_11,            'mu': quiniela.mu,            'sigma': quiniela.sigma        }        portfolio_data.append(record)        df_portfolio = pd.DataFrame(portfolio_data)    portfolio_path = f"{output_dir}/portfolio_final_{jornada}.csv"    df_portfolio.to_csv(portfolio_path, index=False)    output_paths['portfolio'] = portfolio_path        # 2. Métricas de simulación (CSV)    simulation_data = []    for quiniela in portfolio:        sim_record = {            'quiniela_id': quiniela.quiniela_id,            'mu': quiniela.mu,            'sigma': quiniela.sigma,            'pr_10': max(0, quiniela.pr_11 + 0.15),  # Aproximación            'pr_11': quiniela.pr_11,            'pr_12': max(0, quiniela.pr_11 - 0.08),  # Aproximación            'roi_esperado': (quiniela.pr_11 * 90000 / 15 - 1) * 100        }        simulation_data.append(sim_record)        df_simulation = pd.DataFrame(simulation_data)    simulation_path = f"{output_dir}/simulation_metrics_{jornada}.csv"    df_simulation.to_csv(simulation_path, index=False)    output_paths['simulation'] = simulation_path        # 3. Estadísticas del portafolio (JSON)    stats = {        'jornada': str(jornada),        'timestamp': datetime.now().isoformat(),        'n_partidos': len(portfolio[0].signos) if portfolio else 0,        'n_quinielas': len(portfolio),        'n_cores': len([q for q in portfolio if q.tipo == 'Core']),        'n_satelites': len([q for q in portfolio if q.tipo == 'Satélite']),        'pr_11_promedio': np.mean([q.pr_11 for q in portfolio]),        'pr_11_mediana': np.median([q.pr_11 for q in portfolio]),        'pr_11_max': max([q.pr_11 for q in portfolio]),        'pr_11_min': min([q.pr_11 for q in portfolio]),        'mu_promedio': np.mean([q.mu for q in portfolio]),        'sigma_promedio': np.mean([q.sigma for q in portfolio]),        'distribucion_signos': {            'L_promedio': np.mean([q.l_count for q in portfolio]),            'E_promedio': np.mean([q.e_count for q in portfolio]),            'V_promedio': np.mean([q.v_count for q in portfolio])        },        'objetivo_portafolio': 1 - np.prod([1 - q.pr_11 for q in portfolio]),        'costo_total': len(portfolio) * 15,        'ganancia_esperada': np.mean([q.pr_11 for q in portfolio]) * 90000,        'roi_estimado': (np.mean([q.pr_11 for q in portfolio]) * 90000 / (len(portfolio) * 15) - 1) * 100    }        stats_path = f"{output_dir}/portfolio_stats_{jornada}.json"    with open(stats_path, 'w', encoding='utf-8') as f:        json.dump(stats, f, indent=2, ensure_ascii=False)    output_paths['stats'] = stats_path        logger.info(f"✅ Resultados exportados:")    for file_type, path in output_paths.items():        logger.info(f"  {file_type}: {path}")        return output_pathsdef main_pipeline(jornada: Union[str, int], n_partidos: int = 21,                  n_quinielas: int = 30) -> Dict[str, str]:    """Pipeline principal de optimización"""    logger.info(f"=== INICIANDO PIPELINE DE OPTIMIZACIÓN ===")    logger.info(f"Jornada: {jornada}, Partidos: {n_partidos}, Quinielas: {n_quinielas}")        start_time = time.time()        try:        # 1. Cargar probabilidades        matches = load_probabilities_data(jornada, n_partidos)                # 2. Clasificar partidos        classifier = MatchClassifier()        classification = classifier.classify_all_matches(matches)                # 3. Generar portafolio        generator = EnhancedPortfolioGenerator(n_partidos, n_quinielas)                # Generar Cores        cores = generator.generate_core_quinielas(matches, classification)                # Generar Satélites        satelites = generator.generate_satellite_quinielas(cores, matches, classification)                # Combinar portafolio        portfolio = cores + satelites                # 4. Optimizar con GRASP        optimizer = GRASPOptimizer()        optimized_portfolio = optimizer.optimize_portfolio(portfolio, matches)                # 5. Exportar resultados        output_paths = export_portfolio_results(optimized_portfolio, jornada)                elapsed_time = time.time() - start_time        logger.info(f"=== PIPELINE COMPLETADO EN {elapsed_time:.1f}s ===")                return output_paths            except Exception as e:        logger.error(f"❌ Error en pipeline: {e}")        raiseif __name__ == "__main__":    import sys        # Parámetros desde línea de comandos o valores por defecto    jornada = sys.argv[1] if len(sys.argv) > 1 else "2283"    n_partidos = int(sys.argv[2]) if len(sys.argv) > 2 else 21    n_quinielas = int(sys.argv[3]) if len(sys.argv) > 3 else 30        # Ejecutar pipeline    output_paths = main_pipeline(jornada, n_partidos, n_quinielas)        print("\n🎉 PIPELINE COMPLETADO!")    print("📁 Archivos generados:")    for file_type, path in output_paths.items():        print(f"  • {file_type}: {path}")