#!/usr/bin/env python3"""Optimizador mejorado para Progol Engine v2Soporte para 21 partidos (14 regulares + 7 revancha)Generaci√≥n de portafolio Core + Sat√©lites optimizado"""import pandas as pdimport numpy as npimport jsonimport loggingfrom pathlib import Pathimport timefrom typing import Dict, List, Tuple, Optional, Unionfrom dataclasses import dataclassfrom datetime import datetimeimport itertoolsimport random# Configuraci√≥n de logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)@dataclassclass MatchInfo:    """Informaci√≥n de un partido"""    match_id: str    partido: int    tipo: str  # 'Regular' o 'Revancha'    prob_l: float    prob_e: float    prob_v: float    favorito: str    clasificacion: str  # 'Ancla', 'Divisor', 'Tendencia_X', 'Neutro'    confianza: float@dataclassclass QuinielaInfo:    """Informaci√≥n de una quiniela"""    quiniela_id: str    tipo: str  # 'Core' o 'Sat√©lite'    signos: List[str]    source: str    pr_11: float = 0.0    mu: float = 0.0    sigma: float = 0.0    l_count: int = 0    e_count: int = 0    v_count: int = 0class MatchClassifier:    """Clasificador de partidos mejorado"""        def __init__(self, config: Dict = None):        self.config = config or {            'ancla_threshold': 0.60,            'divisor_min': 0.40,            'divisor_max': 0.60,            'empate_threshold': 0.30,            'volatility_threshold': 0.15        }        def classify_match(self, match: MatchInfo) -> str:        """Clasificar un partido seg√∫n sus probabilidades"""        max_prob = max(match.prob_l, match.prob_e, match.prob_v)                # Ancla: alta confianza (>60%)        if max_prob > self.config['ancla_threshold']:            return 'Ancla'                # Tendencia X: empate con probabilidad alta        if match.prob_e > self.config['empate_threshold'] and match.prob_e == max_prob:            return 'Tendencia_X'                # Divisor: probabilidades intermedias        if self.config['divisor_min'] < max_prob <= self.config['divisor_max']:            return 'Divisor'                # Neutro: todo lo dem√°s        return 'Neutro'        def classify_all_matches(self, matches: List[MatchInfo]) -> Dict[str, List[int]]:        """Clasificar todos los partidos"""        classification = {            'Ancla': [],            'Divisor': [],            'Tendencia_X': [],            'Neutro': []        }                for match in matches:            class_type = self.classify_match(match)            match.clasificacion = class_type            classification[class_type].append(match.partido - 1)  # Index 0-based                logger.info(f"Clasificaci√≥n: {dict((k, len(v)) for k, v in classification.items())}")        return classificationclass EnhancedPortfolioGenerator:    """Generador de portafolio mejorado para 21 partidos"""        def __init__(self, n_partidos: int = 21, n_quinielas: int = 30):        self.n_partidos = n_partidos        self.n_quinielas = n_quinielas        self.n_cores = 4        self.n_satelites = n_quinielas - self.n_cores                # L√≠mites de distribuci√≥n        self.dist_limits = {            'L': (0.35, 0.41),  # 35-41% locales            'E': (0.25, 0.33),  # 25-33% empates            'V': (0.30, 0.36)   # 30-36% visitantes        }                # Configuraci√≥n de empates        self.empates_min = max(4, int(0.20 * n_partidos))  # M√≠n 20% empates        self.empates_max = min(8, int(0.35 * n_partidos))  # M√°x 35% empates                logger.info(f"Configuraci√≥n: {n_partidos} partidos, {n_quinielas} quinielas")        logger.info(f"Empates por boleto: {self.empates_min}-{self.empates_max}")        def generate_core_quinielas(self, matches: List[MatchInfo],                                classification: Dict[str, List[int]]) -> List[QuinielaInfo]:        """Generar quinielas Core"""        logger.info("Generando quinielas Core...")                cores = []        anclas = classification['Ancla']                for i in range(self.n_cores):            signos = ['L'] * self.n_partidos  # Inicializar                        # Fijar anclas con su resultado favorito            for match_idx in anclas:                match = matches[match_idx]                if match.prob_l >= max(match.prob_e, match.prob_v):                    signos[match_idx] = 'L'                elif match.prob_e >= max(match.prob_l, match.prob_v):                    signos[match_idx] = 'E'                else:                    signos[match_idx] = 'V'                        # A√±adir empates obligatorios            empates_needed = self.empates_min            empates_current = signos.count('E')                        if empates_current < empates_needed:                # Convertir algunos partidos neutros a empates                neutros = [i for i in classification['Neutro'] if signos[i] != 'E']                tendencias_x = classification['Tendencia_X']                                candidates = tendencias_x + neutros                random.shuffle(candidates)                                for idx in candidates[:empates_needed - empates_current]:                    signos[idx] = 'E'                        # Ajustar distribuci√≥n general            signos = self._adjust_distribution(signos, matches, i)                        # Crear quiniela Core            core = QuinielaInfo(                quiniela_id=f'C{i+1:02d}',                tipo='Core',                signos=signos,                source=f'core_strategy_{i+1}'            )                        # Calcular m√©tricas            self._calculate_quiniela_metrics(core, matches)            cores.append(core)                logger.info(f"‚úÖ {len(cores)} quinielas Core generadas")        return cores        def generate_satellite_quinielas(self, cores: List[QuinielaInfo],                                    matches: List[MatchInfo],                                   classification: Dict[str, List[int]]) -> List[QuinielaInfo]:        """Generar quinielas Sat√©lite"""        logger.info("Generando quinielas Sat√©lite...")                satelites = []        divisores = classification['Divisor']                # Generar pares de sat√©lites anticorrelacionados        n_pares = self.n_satelites // 2                for pair_idx in range(n_pares):            # Sat√©lite A y B del par            for variant in ['A', 'B']:                signos = cores[pair_idx % len(cores)].signos.copy()                                # Invertir divisores para crear anticorrelaci√≥n                for div_idx in divisores:                    current_sign = signos[div_idx]                    match = matches[div_idx]                                        if variant == 'A':                        # Estrategia A: cambiar seg√∫n segunda opci√≥n m√°s probable                        probs = {'L': match.prob_l, 'E': match.prob_e, 'V': match.prob_v}                        sorted_probs = sorted(probs.items(), key=lambda x: x[1], reverse=True)                        signos[div_idx] = sorted_probs[1][0]  # Segunda opci√≥n                    else:                        # Estrategia B: cambiar seg√∫n tercera opci√≥n m√°s probable                        probs = {'L': match.prob_l, 'E': match.prob_e, 'V': match.prob_v}                        sorted_probs = sorted(probs.items(), key=lambda x: x[1], reverse=True)                        signos[div_idx] = sorted_probs[2][0]  # Tercera opci√≥n                                # Ajustar empates                signos = self._ensure_empates_range(signos)                                # Ajustar distribuci√≥n                signos = self._adjust_distribution(signos, matches, pair_idx)                                # Crear sat√©lite                satelite = QuinielaInfo(                    quiniela_id=f'S{len(satelites)+1:02d}',                    tipo='Sat√©lite',                    signos=signos,                    source=f'satellite_pair_{pair_idx+1}_{variant}'                )                                self._calculate_quiniela_metrics(satelite, matches)                satelites.append(satelite)                # Sat√©lites adicionales si es necesario        while len(satelites) < self.n_satelites:            # Generar sat√©lite adicional variando un Core            base_core = cores[len(satelites) % len(cores)]            signos = self._create_variation(base_core.signos, matches, classification)                        satelite = QuinielaInfo(                quiniela_id=f'S{len(satelites)+1:02d}',                tipo='Sat√©lite',                signos=signos,                source=f'satellite_additional_{len(satelites)+1}'            )                        self._calculate_quiniela_metrics(satelite, matches)            satelites.append(satelite)                logger.info(f"‚úÖ {len(satelites)} quinielas Sat√©lite generadas")        return satelites        def _adjust_distribution(self, signos: List[str], matches: List[MatchInfo],                            strategy: int) -> List[str]:        """Ajustar distribuci√≥n de signos seg√∫n l√≠mites hist√≥ricos"""        signos = signos.copy()                # Contar signos actuales        counts = {sign: signos.count(sign) for sign in ['L', 'E', 'V']}        total = len(signos)                # Verificar l√≠mites        for sign, (min_pct, max_pct) in self.dist_limits.items():            current_pct = counts[sign] / total            min_count = int(min_pct * total)            max_count = int(max_pct * total)                        if counts[sign] < min_count:                # Necesitamos m√°s de este signo                needed = min_count - counts[sign]                candidates = [i for i, s in enumerate(signos) if s != sign]                                # Cambiar los menos probables                for i in range(min(needed, len(candidates))):                    idx = candidates[i]                    signos[idx] = sign                                elif counts[sign] > max_count:                # Tenemos demasiados de este signo                excess = counts[sign] - max_count                candidates = [i for i, s in enumerate(signos) if s == sign]                                # Cambiar los menos probables de este signo                for i in range(min(excess, len(candidates))):                    idx = candidates[i]                    # Cambiar al signo m√°s probable que no sea el actual                    match = matches[idx]                    probs = {'L': match.prob_l, 'E': match.prob_e, 'V': match.prob_v}                    del probs[sign]                    best_alternative = max(probs.items(), key=lambda x: x[1])[0]                    signos[idx] = best_alternative                return signos        def _ensure_empates_range(self, signos: List[str]) -> List[str]:        """Asegurar que los empates est√©n en el rango correcto"""        signos = signos.copy()        empates_current = signos.count('E')                if empates_current < self.empates_min:            # Necesitamos m√°s empates            needed = self.empates_min - empates_current            non_empates = [i for i, s in enumerate(signos) if s != 'E']                        for i in range(min(needed, len(non_empates))):                signos[non_empates[i]] = 'E'                        elif empates_current > self.empates_max:            # Tenemos demasiados empates            excess = empates_current - self.empates_max            empates_indices = [i for i, s in enumerate(signos) if s == 'E']                        for i in range(min(excess, len(empates_indices))):                idx = empates_indices[i]                # Cambiar a L o V seg√∫n probabilidades                if random.random() < 0.5:                    signos[idx] = 'L'                else:                    signos[idx] = 'V'                return signos        def _create_variation(self, base_signos: List[str], matches: List[MatchInfo],                          classification: Dict[str, List[int]]) -> List[str]:        """Crear variaci√≥n de una quiniela base"""        signos = base_signos.copy()                # Cambiar algunos divisores y neutros        changeable = classification['Divisor'] + classification['Neutro']        n_changes = min(3, len(changeable))  # Cambiar m√°ximo 3 partidos                to_change = random.sample(changeable, n_changes)                for idx in to_change:            current = signos[idx]            options = ['L', 'E', 'V']            options.remove(current)            signos[idx] = random.choice(options)                # Ajustar empates y distribuci√≥n        signos = self._ensure_empates_range(signos)        signos = self._adjust_distribution(signos, matches, 0)                return signos        def _calculate_quiniela_metrics(self, quiniela: QuinielaInfo, matches: List[MatchInfo]):        """Calcular m√©tricas de una quiniela"""        # Contar signos        quiniela.l_count = quiniela.signos.count('L')        quiniela.e_count = quiniela.signos.count('E')        quiniela.v_count = quiniela.signos.count('V')                # Calcular Pr[‚â•11] aproximada        prob_aciertos = []        for i, signo in enumerate(quiniela.signos):            match = matches[i]            if signo == 'L':                prob_aciertos.append(match.prob_l)            elif signo == 'E':                prob_aciertos.append(match.prob_e)            else:  # 'V'                prob_aciertos.append(match.prob_v)                # Simulaci√≥n Monte Carlo r√°pida para Pr[‚â•11]        n_sim = 1000        aciertos_sim = []                for _ in range(n_sim):            aciertos = sum(1 for p in prob_aciertos if random.random() < p)            aciertos_sim.append(aciertos)                quiniela.mu = np.mean(aciertos_sim)        quiniela.sigma = np.std(aciertos_sim)        quiniela.pr_11 = sum(1 for a in aciertos_sim if a >= 11) / n_simclass GRASPOptimizer:    """Optimizador GRASP mejorado para portafolios"""        def __init__(self, config: Dict = None):        self.config = config or {            'max_iterations': 100,            'alpha': 0.3,            'time_limit': 300,            'improvement_threshold': 0.001        }        def optimize_portfolio(self, quinielas: List[QuinielaInfo],                           matches: List[MatchInfo]) -> List[QuinielaInfo]:        """Optimizar portafolio usando GRASP"""        logger.info("Iniciando optimizaci√≥n GRASP...")                start_time = time.time()        best_portfolio = quinielas.copy()        best_objective = self._calculate_portfolio_objective(best_portfolio)                logger.info(f"Objetivo inicial: {best_objective:.6f}")                iterations = 0        improvements = 0                while (iterations < self.config['max_iterations'] and                time.time() - start_time < self.config['time_limit']):                        # Fase de construcci√≥n            candidate_portfolio = self._grasp_construction(quinielas, matches)                        # Fase de mejora local            improved_portfolio = self._local_search(candidate_portfolio, matches)                        # Evaluar objetivo            objective = self._calculate_portfolio_objective(improved_portfolio)                        # Actualizar mejor soluci√≥n            if objective > best_objective + self.config['improvement_threshold']:                best_portfolio = improved_portfolio                best_objective = objective                improvements += 1                logger.info(f"Iteraci√≥n {iterations}: Nueva mejor soluci√≥n {best_objective:.6f}")                        iterations += 1                elapsed_time = time.time() - start_time        logger.info(f"Optimizaci√≥n completada: {iterations} iteraciones, "                   f"{improvements} mejoras, {elapsed_time:.1f}s")                return best_portfolio        def _calculate_portfolio_objective(self, portfolio: List[QuinielaInfo]) -> float:        """Calcular objetivo del portafolio (1 - Œ†(1 - Pr[‚â•11]))"""        prob_no_premio = 1.0        for quiniela in portfolio:            prob_no_premio *= (1 - quiniela.pr_11)                return 1 - prob_no_premio        def _grasp_construction(self, base_portfolio: List[QuinielaInfo],                            matches: List[MatchInfo]) -> List[QuinielaInfo]:        """Construcci√≥n golosa con elemento aleatorio"""        portfolio = []                for quiniela in base_portfolio:            # Crear variaci√≥n con probabilidad alpha            if random.random() < self.config['alpha']:                new_quiniela = self._create_random_variation(quiniela, matches)            else:                new_quiniela = quiniela                        portfolio.append(new_quiniela)                return portfolio        def _local_search(self, portfolio: List[QuinielaInfo],                      matches: List[MatchInfo]) -> List[QuinielaInfo]:        """B√∫squeda local para mejorar portafolio"""        improved = portfolio.copy()        current_objective = self._calculate_portfolio_objective(improved)                # Intentar swaps en cada quiniela        for i, quiniela in enumerate(improved):            for j in range(len(quiniela.signos)):                # Probar cambiar el signo del partido j                original_sign = quiniela.signos[j]                                for new_sign in ['L', 'E', 'V']:                    if new_sign != original_sign:                        # Hacer el cambio                        quiniela.signos[j] = new_sign                        self._calculate_quiniela_metrics(quiniela, matches)                                                # Evaluar nuevo objetivo                        new_objective = self._calculate_portfolio_objective(improved)                                                if new_objective > current_objective:                            # Mantener el cambio                            current_objective = new_objective                        else:                            # Revertir el cambio                            quiniela.signos[j] = original_sign                            self._calculate_quiniela_metrics(quiniela, matches)                return improved        def _create_random_variation(self, base_quiniela: QuinielaInfo,                                 matches: List[MatchInfo]) -> QuinielaInfo:        """Crear variaci√≥n aleatoria de una quiniela"""        new_signos = base_quiniela.signos.copy()                # Cambiar 1-3 partidos aleatoriamente        n_changes = random.randint(1, 3)        positions = random.sample(range(len(new_signos)), n_changes)                for pos in positions:            current = new_signos[pos]            options = ['L', 'E', 'V']            options.remove(current)            new_signos[pos] = random.choice(options)                # Crear nueva quiniela        new_quiniela = QuinielaInfo(            quiniela_id=base_quiniela.quiniela_id,            tipo=base_quiniela.tipo,            signos=new_signos,            source=f"{base_quiniela.source}_variation"        )                self._calculate_quiniela_metrics(new_quiniela, matches)        return new_quiniela        def _calculate_quiniela_metrics(self, quiniela: QuinielaInfo, matches: List[MatchInfo]):        """Calcular m√©tricas (reutilizar m√©todo del generador)"""        generator = EnhancedPortfolioGenerator()        generator._calculate_quiniela_metrics(quiniela, matches)def load_probabilities_data(jornada: Union[str, int], n_partidos: int = 21) -> List[MatchInfo]:    """Cargar datos de probabilidades"""    try:        # Intentar cargar archivo real        prob_file = f"data/processed/prob_final_{jornada}.csv"                if Path(prob_file).exists():            df = pd.read_csv(prob_file)            logger.info(f"Cargando probabilidades desde {prob_file}")        else:            # Generar datos de ejemplo            logger.warning(f"Archivo {prob_file} no encontrado, generando datos de ejemplo")            df = generate_sample_probabilities(jornada, n_partidos)                # Convertir a MatchInfo        matches = []        for _, row in df.iterrows():            match = MatchInfo(                match_id=row.get('match_id', f'{jornada}-{row["partido"]}'),                partido=row['partido'],                tipo=row.get('tipo', 'Regular' if row['partido'] <= 14 else 'Revancha'),                prob_l=row['p_final_L'],                prob_e=row['p_final_E'],                prob_v=row['p_final_V'],                favorito=row.get('favorito', 'L'),                clasificacion='',                confianza=max(row['p_final_L'], row['p_final_E'], row['p_final_V'])            )            matches.append(match)                logger.info(f"‚úÖ {len(matches)} partidos cargados")        return matches            except Exception as e:        logger.error(f"Error cargando probabilidades: {e}")        return generate_sample_probabilities(jornada, n_partidos)def generate_sample_probabilities(jornada: Union[str, int], n_partidos: int) -> pd.DataFrame:    """Generar probabilidades de ejemplo"""    logger.info(f"Generando {n_partidos} probabilidades de ejemplo")        data = []    for i in range(n_partidos):        # Probabilidades realistas para f√∫tbol        p_l = np.random.uniform(0.25, 0.55)        p_e = np.random.uniform(0.20, 0.35)        p_v = 1.0 - p_l - p_e                # Normalizar        total = p_l + p_e + p_v        p_l /= total        p_e /= total          p_v /= total                favorito = 'L' if p_l >= max(p_e, p_v) else ('E' if p_e >= p_v else 'V')                data.append({            'match_id': f'{jornada}-{i+1}',            'partido': i + 1,            'tipo': 'Regular' if i < 14 else 'Revancha',            'p_final_L': p_l,            'p_final_E': p_e,            'p_final_V': p_v,            'favorito': favorito        })        return pd.DataFrame(data)def export_portfolio_results(portfolio: List[QuinielaInfo], jornada: Union[str, int],                            output_dir: str = "data/processed") -> Dict[str, str]:    """Exportar resultados del portafolio"""    output_paths = {}        # Crear directorio si no existe    Path(output_dir).mkdir(parents=True, exist_ok=True)        # 1. Portafolio principal (CSV)    portfolio_data = []    for quiniela in portfolio:        record = {            'quiniela_id': quiniela.quiniela_id,            'tipo': quiniela.tipo,            'source': quiniela.source,            **{f'P{i+1}': quiniela.signos[i] for i in range(len(quiniela.signos))},            'l_count': quiniela.l_count,            'e_count': quiniela.e_count,            'v_count': quiniela.v_count,            'pr_11': quiniela.pr_11,            'mu': quiniela.mu,            'sigma': quiniela.sigma        }        portfolio_data.append(record)        df_portfolio = pd.DataFrame(portfolio_data)    portfolio_path = f"{output_dir}/portfolio_final_{jornada}.csv"    df_portfolio.to_csv(portfolio_path, index=False)    output_paths['portfolio'] = portfolio_path        # 2. M√©tricas de simulaci√≥n (CSV)    simulation_data = []    for quiniela in portfolio:        sim_record = {            'quiniela_id': quiniela.quiniela_id,            'mu': quiniela.mu,            'sigma': quiniela.sigma,            'pr_10': max(0, quiniela.pr_11 + 0.15),  # Aproximaci√≥n            'pr_11': quiniela.pr_11,            'pr_12': max(0, quiniela.pr_11 - 0.08),  # Aproximaci√≥n            'roi_esperado': (quiniela.pr_11 * 90000 / 15 - 1) * 100        }        simulation_data.append(sim_record)        df_simulation = pd.DataFrame(simulation_data)    simulation_path = f"{output_dir}/simulation_metrics_{jornada}.csv"    df_simulation.to_csv(simulation_path, index=False)    output_paths['simulation'] = simulation_path        # 3. Estad√≠sticas del portafolio (JSON)    stats = {        'jornada': str(jornada),        'timestamp': datetime.now().isoformat(),        'n_partidos': len(portfolio[0].signos) if portfolio else 0,        'n_quinielas': len(portfolio),        'n_cores': len([q for q in portfolio if q.tipo == 'Core']),        'n_satelites': len([q for q in portfolio if q.tipo == 'Sat√©lite']),        'pr_11_promedio': np.mean([q.pr_11 for q in portfolio]),        'pr_11_mediana': np.median([q.pr_11 for q in portfolio]),        'pr_11_max': max([q.pr_11 for q in portfolio]),        'pr_11_min': min([q.pr_11 for q in portfolio]),        'mu_promedio': np.mean([q.mu for q in portfolio]),        'sigma_promedio': np.mean([q.sigma for q in portfolio]),        'distribucion_signos': {            'L_promedio': np.mean([q.l_count for q in portfolio]),            'E_promedio': np.mean([q.e_count for q in portfolio]),            'V_promedio': np.mean([q.v_count for q in portfolio])        },        'objetivo_portafolio': 1 - np.prod([1 - q.pr_11 for q in portfolio]),        'costo_total': len(portfolio) * 15,        'ganancia_esperada': np.mean([q.pr_11 for q in portfolio]) * 90000,        'roi_estimado': (np.mean([q.pr_11 for q in portfolio]) * 90000 / (len(portfolio) * 15) - 1) * 100    }        stats_path = f"{output_dir}/portfolio_stats_{jornada}.json"    with open(stats_path, 'w', encoding='utf-8') as f:        json.dump(stats, f, indent=2, ensure_ascii=False)    output_paths['stats'] = stats_path        logger.info(f"‚úÖ Resultados exportados:")    for file_type, path in output_paths.items():        logger.info(f"  {file_type}: {path}")        return output_pathsdef main_pipeline(jornada: Union[str, int], n_partidos: int = 21,                  n_quinielas: int = 30) -> Dict[str, str]:    """Pipeline principal de optimizaci√≥n"""    logger.info(f"=== INICIANDO PIPELINE DE OPTIMIZACI√ìN ===")    logger.info(f"Jornada: {jornada}, Partidos: {n_partidos}, Quinielas: {n_quinielas}")        start_time = time.time()        try:        # 1. Cargar probabilidades        matches = load_probabilities_data(jornada, n_partidos)                # 2. Clasificar partidos        classifier = MatchClassifier()        classification = classifier.classify_all_matches(matches)                # 3. Generar portafolio        generator = EnhancedPortfolioGenerator(n_partidos, n_quinielas)                # Generar Cores        cores = generator.generate_core_quinielas(matches, classification)                # Generar Sat√©lites        satelites = generator.generate_satellite_quinielas(cores, matches, classification)                # Combinar portafolio        portfolio = cores + satelites                # 4. Optimizar con GRASP        optimizer = GRASPOptimizer()        optimized_portfolio = optimizer.optimize_portfolio(portfolio, matches)                # 5. Exportar resultados        output_paths = export_portfolio_results(optimized_portfolio, jornada)                elapsed_time = time.time() - start_time        logger.info(f"=== PIPELINE COMPLETADO EN {elapsed_time:.1f}s ===")                return output_paths            except Exception as e:        logger.error(f"‚ùå Error en pipeline: {e}")        raiseif __name__ == "__main__":    import sys        # Par√°metros desde l√≠nea de comandos o valores por defecto    jornada = sys.argv[1] if len(sys.argv) > 1 else "2283"    n_partidos = int(sys.argv[2]) if len(sys.argv) > 2 else 21    n_quinielas = int(sys.argv[3]) if len(sys.argv) > 3 else 30        # Ejecutar pipeline    output_paths = main_pipeline(jornada, n_partidos, n_quinielas)        print("\nüéâ PIPELINE COMPLETADO!")    print("üìÅ Archivos generados:")    for file_type, path in output_paths.items():        print(f"  ‚Ä¢ {file_type}: {path}")